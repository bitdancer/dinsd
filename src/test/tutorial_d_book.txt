Disnd and An Introduction to Relational Database Theory
=======================================================


Introduction
------------

Dinsd was initially developed while I went through the book

    An Introduction to Relational Database Theory
    by Hugh Darwen

This book uses his and C. J. Date's notional ``D`` implementation, *Tutorial
D*, and gives various examples and problems based on *Tutorial D* to elucidate
the concepts of Relational Algebra.  ``D`` and *Tutorial D* are in turn
defined fully in Hugh and C. J.'s seminal work

    The Third Manifesto

This file writes out various examples in dinsd that correspond to examples
and/or problems from the book, as well as other examples that were inspired by
the book or explored during the writing of dinsd.  The examples here do not
particularly follow the book, as writing the implementation required hoping
around a bit in the conceptual space, but the general pattern does follow
the book.

Where reference is made to specific page numbers or figures in AIRTD, this is
based on the bookboon.com edition of the book as available for download on
November 1st, 2012.

This file contains blocks of tests that are meant to exercise edge cases as
well as the primary test cases and examples, because it is the test document
that I used as I was building the system.  It is, therefore, a cross between a
design document, a literate test document, and a detailed discussion of the
system mechanics.  It may not be the best possible introduction to dinsd, but
if you can make your way through it you will have a fairly deep understanding
of dinsd and its relationship to TTM and its correspondence (or lack thereof)
to *Tutorial D*.


Scalars, Rows, and Relations (and a Few Words About Databases)
--------------------------------------------------------------

Databases and Terminology
~~~~~~~~~~~~~~~~~~~~~~~~~

The concept of a database holding a set of relations is central to *Tutorial
D*, but the process for defining a database is only introduced implicitly.  We
will do the same, talking about the conceptual framework of the database,
but defer the discussion of the syntax for defining one until later.

A database in dinsd consists of a container for the database, and a name and
definition for all of the relations that are stored in the container.  This is
what is usually called a "schema" in SQL.  Dinsd refers to it as a "DBDef"
(Database Definition).  Unlike a traditional SQL DBMS, dinsd does not store
the ``DBDef`` "in the catalog"; instead the Python program holds the
``DBDef``, and only the data is stored in the persistent store.  This means
that dnsd is not by itself a DBMS...in order to have a dinsd based DBMS, you
would need to write an application that would manage ``DBDef`` definitions as
data objects, and persist them.  While this is conceptually possible, it is
not something I need for the first intended application of dinsd and so is not
addressed here.

The facilities for defining databases and relations are provided by the dinsd
module ``dbdef``.

    >>> from dinsd import dbdef

A database is a set of relations.  Per TTM and AIRDT, a relation consists of a
header plus a set of ``tuples`` that conform to that header.  Since Python
already uses the term ``tuple`` to refer to a different concept, we will fall
back to the less precise but more widely recognized term ``row``.  I'm sure
the authors of TTM would/will be annoyed by this, but it is less confusing
than trying to reuse the world ``tuple`` in a Python context.

So, a relation consists of a name and a header.  The header consists of a list
of attributes, with each attribute having a type.


Types, User Defined Types, and Scalars
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Python is strictly typed.  Defining new types in Python is very simple:  you
define a class.  (Classes are, in fact, of type ``type`` in Python).  So, to
define the type for an attribute, we need a class that is that type.  For
standard types (``int``, ``str``, etc), we can use the Python built in types.
For what TTM calls "user defined types", we define a new class.

In order to maintain consistency, every user defined scaler type (ie:
non-relation type) used with dinsd must conform to the common syntax and
semantics of the Python built in types:  the type constructor at a minimum
accepts one argument, and either raises an error if the argument (the
"selector" in TTM/AIRDT terms) cannot be converted into a valid instance of
the type, or a valid instance of the type if it can be.  In Python terms, this
means that the class's ``__init__`` method must accept at least one positional
argument.  (For the purposes of dinsd, this argument should always be present,
even if it is optional in the class definition for other reasons.)

It is also critical that, like the Python built in types, the user defined
type accept an instance of itself as a valid selector, and return an
equivalent instance.  (Note that this requirement is not true for *Tutorial
D*.  We'll discuss why it is true for dinsd below.)

In addition to the conformance checking in the ``__init__`` method, there are
some auxiliary methods that every user defined scaler type must have.
Therefore dinsd provides a base type for such user defines scalers, named
``Scaler``.  A simple ``Scaler`` type must always store its value in an attribute
named ``value``.

There is nothing preventing an application from defining a type without using
``Scaler`` as the superclass, or using ``Scaler`` and implementing a more
complex value store, but if an application does so it is responsible for
correctly implementing the equivalents of all of the methods that ``Scaler``
provides.  Specifically, it must provide all the methods to define a total
ordering of the values, as required by TTM.

So, we can now define the ``SID`` and ``CID`` types that are introduced in
chapter 2 of AIRDT:

    >>> class ID(dbdef.Scaler):
    ...
    ...     def __init__(self, id):
    ...         if isinstance(id, self.__class__):
    ...             self.value = id.value
    ...             return
    ...         if not isinstance(id, str):
    ...             raise TypeError(
    ...                 "Expected str but passed {}".format(type(id)))
    ...         if (2 <= len(id) <=4 and id.startswith(self.firstchar) and
    ...                 id[1:].isdigit()):
    ...             self.value = id
    ...         else:
    ...             raise TypeError("Expected '{}' followed by one to "
    ...                             "three digits".format(self.firstchar))
    ...
    >>> class SID(ID):
    ...     firstchar = 'S'
    ...
    >>> class CID(ID):
    ...     firstchar = 'C'

This definition corresponds to example 2.4 on page 47 of AIRDT.  It looks
somewhat more complicated, but this is primarily because defining the error
messages resulting from "selection" failure, whereas example 2.4 is leaving
those error messages to be automatically generated by the *Tutorial D* system.

Semantically the examples are equivalent.  We are using Python built
in functions for the checks, whereas in *Tutorial D* the check functions are
user defined (and their definition is deferred to later in the book).
The *Tutorial D* ``C CHAR`` declaration corresponds to our ``self.value =
id``, with the difference that our self.value is not typed.  The *value* has a
type, which our code is constraining to be ``str`` (Python's equivalent
of *Tutorial D*'s ``CHAR``), but as is normal in Python the name we store it
under is not itself typed.

To prove that this (straightforward Python) implementation is correct:

    >>> SID('S1')
    SID('S1')
    >>> CID('C1')
    CID('C1')
    >>> SID(SID('S1'))
    SID('S1')
    >>> print(SID('S2'))
    S2
    >>> SID('1')
    Traceback (most recent call last):
        ...
    TypeError: Expected 'S' followed by one to three digits
    >>> CID(1)
    Traceback (most recent call last):
        ...
    TypeError: Expected str but passed <class 'int'>
    >>> SID('C1')
    Traceback (most recent call last):
        ...
    TypeError: Expected 'S' followed by one to three digits
    >>> CID('C0003')
    Traceback (most recent call last):
        ...
    TypeError: Expected 'C' followed by one to three digits
    >>> SID(CID('C1'))
    Traceback (most recent call last):
        ...
    TypeError: Expected str but passed <class '__main__.CID'>
    >>> SID('S1') == SID('S1')
    True
    >>> SID('S1') != CID('C1')
    True
    >>> SID('S2') == SID(SID('S2'))
    True
    >>> SID('S1') < SID('S2')
    True
    >>> CID('C7') >= CID('C7')
    True
    >>> SID('S1') > CID('C2')
    Traceback (most recent call last):
        ...
    TypeError: unorderable types: SID() > CID()


Defining and Instantiating Relations
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

A relation in dinsd is also a class, which is nice because in TTM it is also a
type, making this consistent between TTM and dinsd/Python.  As mentioned
above, for a relation, the class (type) definition consists of a list of
attributes and their types.

We will demonstrate this by defining the example relation used throughout the
first couple chapters of AIRDT.  This corresponds to the  *Tutorial D* type
definition that is given on page 42 of AIRDT.

    >>> class IsEnrolledOn(dbdef.Relation):
    ...     student_id = SID
    ...     name = str
    ...     course_id = CID

Because relations share a common semantic, we don't need to define an explicit
``__init__`` function.  All ``Relation`` types automatically have an
``__init__`` method that allows us to construct a relation (relvar) of that
type by providing data to extend the relation.

The most verbose and most general way of creating such a relation instance is
as follows:

    >>> is_enrolled_on = IsEnrolledOn(
    ...     IsEnrolledOn.row({'student_id': SID('S1'), 'course_id': CID('C1'), 'name': 'Anne'}),
    ...     IsEnrolledOn.row({'student_id': SID('S1'), 'course_id': CID('C2'), 'name': 'Anne'}),
    ...     IsEnrolledOn.row({'student_id': SID('S2'), 'course_id': CID('C1'), 'name': 'Boris'}),
    ...     IsEnrolledOn.row({'student_id': SID('S3'), 'course_id': CID('C3'), 'name': 'Cindy'}),
    ...     IsEnrolledOn.row({'student_id': SID('S4'), 'course_id': CID('C1'), 'name': 'Devinder'}),
    ...     )

This corresponds directly to the relation definition in example 2.3 on page
45.  As I indicated earlier, we are using the term ``row`` instead of the term
``tuple`` to avoid confusion with the Python ``tuple`` type.

If you compare the above "relation literal" with the one from example 2.3 in
AIRDT, you might notice a major difference between disnd and *Tutorial D*, one
of the ones that makes dinsd not technically compatible with TTM.  In TTM
(and *Tutorial D*) a type is completely characterized by the names of the
attributes and the types of the values.  If two definitions or two literals
refer to the *same* set of names, with the value associated with each name
having the *same* type, then the two are considered to be *exactly* the same
type for all purposes.  Python, on the other hand, bases type identity on the
identity of the *object* that defines the type.  Thus in our version of the
Relation literal above, we must explicitly name the type that we are
instantiating, so that Python can follow the pointer to the single type object
that defines this Relation type.  While this technically violates TTM, in
practice we allow relvars that have conformant types in the TTM sense to fully
interoperate.  Thus in practice the difference has a consequence only in the
way in which Relations and Tuples are created, and not on the way in which
they are used.

You will also note that dinsd does not provide any direct syntax for defining
a row independent of any Relation, unlike *Tutorial D*, which provides the
TUPLE keyword for both type and literal definition.  In disd a row selector
function is accessible only from the corresponding `Relation` type that uses
the same header.  This also does not fully conform to TTM, but I haven't
found a need to define a row without also defining the corresponding Relation,
so I don't think it is a significant omission.

The instantiation above is *very* wordy.  Given that in dinsd we know which
type of relation we are instantiating, we can provide usefully simpler
representations.

First, we know that the body of the relation is a list of rows, so there is no
need to pass in explicitly constructed rows.  Instead, if the init method is
passed a simple Python dictionary, it can do the conversion-to-row itself:

    >>> is_enrolled_on2 = IsEnrolledOn(
    ...     {'student_id': SID('S1'), 'course_id': CID('C1'), 'name': 'Anne'},
    ...     {'student_id': SID('S1'), 'course_id': CID('C2'), 'name': 'Anne'},
    ...     {'student_id': SID('S2'), 'course_id': CID('C1'), 'name': 'Boris'},
    ...     {'student_id': SID('S3'), 'course_id': CID('C3'), 'name': 'Cindy'},
    ...     {'student_id': SID('S4'), 'course_id': CID('C1'), 'name': 'Devinder'},
    ...     )

Second, by relaxing from the purity of never using ordered tuples we can
significantly reduce the typing required to enter a relation literal:

    >>> is_enrolled_on3 = IsEnrolledOn(
    ...     ('student_id', 'course_id', 'name'),
    ...     (SID('S1'), CID('C1'), 'Anne'),
    ...     (SID('S1'), CID('C2'), 'Anne'),
    ...     (SID('S2'), CID('C1'), 'Boris'),
    ...     (SID('S3'), CID('C3'), 'Cindy'),
    ...     (SID('S4'), CID('C1'), 'Devinder'),
    ...     )

Here the ``__init__`` method sees that it is being passed (Python) tuples
instead of dictionaries, and takes the first such tuple as the ordered list
of attributes and each subsequent tuple as a correspondingly ordered list
of attribute values.

Finally, by taking advantage of the fact that we know the type of the
attributes and have access to the selector function for that type, we can
produce a minimally simple representation by not requiring the type of the
attribute value to explicitly specified in the literal:

    >>> is_enrolled_on4 = IsEnrolledOn(
    ...     ('student_id', 'course_id', 'name'),
    ...     ('S1', 'C1', 'Anne'),
    ...     ('S1', 'C2', 'Anne'),
    ...     ('S2', 'C1', 'Boris'),
    ...     ('S3', 'C3', 'Cindy'),
    ...     ('S4', 'C1', 'Devinder'),
    ...     )

There is no loss of type-safety here, since each selector is passed through
the type constructor, which will raise an error if the argument value does
not conform to the selector.

You can see now why it is critical that the type constructor accept an
instance of itself as valid:  the relation constructor will always pass the
value of an attribute through the corresponding type function for validation,
and an instance of that type must be reported as valid.

It might appear as though there is another step of simplification we could do:
not require the first tuple of attribute names, but instead assume the same
ordering as that used in the relation definition.  Although it would
technically be possible to do this in Python (by using an ``OrderedDict`` for
the Relation class dictionary) it is not a natural fit for normal Python
semantics, and would (unlike, I believe, the previous simplifications)
definitely violate the spirit of TTM by making the meaning of a relation
literal dependent on the order of definition of the attributes in the relation
definition.  In contrast, the final simplification above is not dependent on
the definition order, only on the types, which cannot change.

So, in dinsd you can choose the level of correspondence to the *Tutorial D*
literal notation that you prefer.  All of the above representations produce
the same relvar value:

    >>> is_enrolled_on == is_enrolled_on2 == is_enrolled_on3 == is_enrolled_on4
    True

It's ``repr`` is one of the more compact version of the literal representation:

    >>> is_enrolled_on     # doctest: +NORMALIZE_WHITESPACE
    IsEnrolledOn(('course_id', 'name',    'student_id'),
                   (CID('C1'), 'Anne',     SID('S1')),
                   (CID('C1'), 'Boris',    SID('S2')),
                   (CID('C1'), 'Devinder', SID('S4')),
                   (CID('C2'), 'Anne',     SID('S1')),
                   (CID('C3'), 'Cindy',    SID('S3')))

Of course, the real repr is a single line and so is not as pretty as the
example makes it look.  We've lined up the example so that you can notice that
the attributes are sorted alphabetically, and the rows are sorted according to
their values as tuples.  We could also just allow them to be in their
"natural" order, but in Python that is semi-random and it is more convenient
to have a consistent ordering in the representation.

The ``str`` (printed) representation is likewise sorted, but is in a more
convenient format for inspecting the relation:

    >>> print(is_enrolled_on)
    +-----------+----------+------------+
    | course_id | name     | student_id |
    +-----------+----------+------------+
    | C1        | Anne     | S1         |
    | C1        | Boris    | S2         |
    | C1        | Devinder | S4         |
    | C2        | Anne     | S1         |
    | C3        | Cindy    | S3         |
    +-----------+----------+------------+

Testing the Edges
~~~~~~~~~~~~~~~~~

So much for the basics and the simple initial example from AIRDT Chapter 2.
Let's take a look at some edge cases to make sure the code handles them.

First of all, we can create an empty Relation:

    >>> is_enrolled_on = IsEnrolledOn()
    >>> is_enrolled_on
    IsEnrolledOn(('course_id', 'name', 'student_id'))
    >>> print(is_enrolled_on)
    +-----------+------+------------+
    | course_id | name | student_id |
    +-----------+------+------------+
    +-----------+------+------------+

The dictionary passed to the row constructor must have the right number of
values:

    >>> IsEnrolledOn.row({})
    Traceback (most recent call last):
        ...
    TypeError: Expected 3 attributes, got 0
    >>> IsEnrolledOn.row({'student_id': 'S1', 'name': 'foo'})
    Traceback (most recent call last):
        ...
    TypeError: Expected 3 attributes, got 2
    >>> IsEnrolledOn.row({'student_id': 'S1', 'name': 'foo',
    ...                         'course_id': 'C1', 'bar': 1})
    Traceback (most recent call last):
        ...
    TypeError: Expected 3 attributes, got 4

And the attribute names must match those defined in the relation:

    >>> IsEnrolledOn.row({'student_id': 'S1', 'name': 'foo', 'bad': 1})
    Traceback (most recent call last):
        ...
    TypeError: Invalid attribute name bad

The values must be valid:

    >>> IsEnrolledOn.row({'student_id': 'S1', # doctest: +NORMALIZE_WHITESPACE
    ...                      'name': 'foo', 'course_id': 1})
    Traceback (most recent call last):
        ...
    TypeError: Expected str but passed <class 'int'>, 1 invalid for attribute course_id
    >>> IsEnrolledOn.row({'student_id': 'S1', # doctest: +NORMALIZE_WHITESPACE
    ...                     'name': 'foo', 'course_id': 'S1'})
    Traceback (most recent call last):
        ...
    TypeError: Expected 'C' followed by one to three digits, 'S1' invalid
         for attribute course_id

But it is OK to use the selector form ('C1') rather than the full scaler
value form (CID('C1')):

    >>> r = IsEnrolledOn.row(
    ...         {'student_id': 'S1', 'name': 'foo', 'course_id': 'C1'})

A row also has a distinct ``repr`` and ``str``:

    >>> r                       # doctest: +NORMALIZE_WHITESPACE
    IsEnrolledOn.row({'course_id': CID('C1'), 'name': 'foo', 'student_id':
                        SID('S1')})
    >>> print(r)
    (course_id=C1, name=foo, student_id=S1)

You will note that as with the ``repr``  and ``str`` of a ``Relation``, the
``repr`` and ``str`` of a ``row`` is sorted by the attribute names.  The
``str`` representation of a ``row`` is not nearly as useful as that of
a ``Relation``, but is provided for completeness.

The same type checking happens when instantiating a Relation using the
shorthand, and additionally reports which row is in error:

    >>> IsEnrolledOn(('course_id', 'name'),
    ...               ('S1', 'Anne'))
    Traceback (most recent call last):
        ...
    TypeError: Expected 3 attributes, got 2 in header row for IsEnrolledOn
    >>> IsEnrolledOn(('course_id', 'name', 'student_id'),
    ...               ('C1', 'Anne'))
    Traceback (most recent call last):
        ...
    TypeError: Expected 3 attributes, got 2 in row 1 for IsEnrolledOn
    >>> IsEnrolledOn(('course_id', 'name', 'student_id'),
    ...               ('C1', 'Anne', 'S1'),
    ...               ('C2', 'Anne', 'S1', 'foo'),
    ...               )
    Traceback (most recent call last):
        ...
    TypeError: Expected 3 attributes, got 4 in row 2 for IsEnrolledOn
    >>> IsEnrolledOn(('course_id', 'name', 'foo'),
    ...               ('C1', 'Anne', 'S1'),
    ...               )
    Traceback (most recent call last):
        ...
    AttributeError: 'IsEnrolledOn' relation has no attribute 'foo'
    >>> IsEnrolledOn(                   # doctest: +NORMALIZE_WHITESPACE
    ...               ('course_id', 'name', 'student_id'),
    ...               ('C1', 'Anne', 'S1'),
    ...               ('C2', 'Anne', 'C1'),
    ...               )
    Traceback (most recent call last):
        ...
    TypeError: Expected 'S' followed by one to three digits, 'C1' invalid for
        attribute student_id in row 2



Relational Operators
--------------------

Analogous to how the classes used for defining row and relation types are
collected into the dinsd ``dbdef`` namespace, the methods used to define
various relational operators are defined in their own namespace, in this case
named ``op``.  It is annoying to type ``op.`` in front of the operators,
though, since we type them much more often than the dbdef class names.
So we'll import each operator at the start of the section discussing it.


Example Relations
~~~~~~~~~~~~~~~~~

Here are the two relations used in the examples in Chapter 4 of AIRDT:

    >>> class IsCalled(dbdef.Relation):
    ...     student_id = SID
    ...     name = str
    >>> is_called = IsCalled(
    ...     ('student_id',  'name'),
    ...     ('S1',          'Anne'),
    ...     ('S2',          'Boris'),
    ...     ('S3',          'Cindy'),
    ...     ('S4',          'Devinder'),
    ...     ('S5',          'Boris'),
    ...     )
    >>> print(is_called)
    +----------+------------+
    | name     | student_id |
    +----------+------------+
    | Anne     | S1         |
    | Boris    | S2         |
    | Boris    | S5         |
    | Cindy    | S3         |
    | Devinder | S4         |
    +----------+------------+
    >>> class IsEnrolledOn(dbdef.Relation):
    ...     student_id = SID
    ...     course_id = CID
    >>> is_enrolled_on = IsEnrolledOn(
    ...     ('student_id',  'course_id'),
    ...     ('S1',          'C1'),
    ...     ('S1',          'C2'),
    ...     ('S2',          'C1'),
    ...     ('S3',          'C3'),
    ...     ('S4',          'C1'),
    ...     )
    >>> print(is_enrolled_on)
    +-----------+------------+
    | course_id | student_id |
    +-----------+------------+
    | C1        | S1         |
    | C1        | S2         |
    | C1        | S4         |
    | C2        | S1         |
    | C3        | S3         |
    +-----------+------------+

Here we have changed the meaning of the names IsEnrolledOn and is_enrolled_on.
We would not be allowed to do this in *Tutorial D* or *TTM* without first
declaring variables as discarded and *then* defining new types for them.
Python sees that as pointless busywork and does not require it, but it is one
of the things that makes dinsd not TTM compliant.  (We will see later,
however, that disd *does* implement semi-statically-typed relvars inside
databases.)

Python keeps track of objects by pointer, though, not by name, so to Python
the type of the relation pointed to now by is_enrolled_on is different from
the type of the relation pointed to by the old is_enrolled_on variables, even
though the two relation types have the same identifier:

    >>> type(is_enrolled_on).__name__ == type(is_enrolled_on2).__name__
    True
    >>> type(is_enrolled_on) == type(is_enrolled_on2)
    False

That is, Python is *strongly typed*, even though it is also *dynamically
typed*.  (In fact, if you consider that it is really the object that is typed,
and that there are no real 'variables' in Python, just names that contain
references to objects, disnd probably does technically comply with TTM...but
not with its spirit, which requires static typing.)


display
~~~~~~~

``display`` is not a relational algebra function, but we introduce it here
because it is useful in the examples, and it is located in the ``op``
namespace.

    >>> from dinsd.op import display

The value returned by ``display`` is very similar to the value returned
by turning a relation in to a string, except that we can control the
order of the columns in the resulting table display.  Using ``display``
we can print the relations in the same column order that is used in AITDM:

    >>> print(display(is_called, 'student_id', 'name'))
    +------------+----------+
    | student_id | name     |
    +------------+----------+
    | S1         | Anne     |
    | S2         | Boris    |
    | S3         | Cindy    |
    | S4         | Devinder |
    | S5         | Boris    |
    +------------+----------+
    >>> print(display(is_enrolled_on, 'student_id', 'course_id'))
    +------------+-----------+
    | student_id | course_id |
    +------------+-----------+
    | S1         | C1        |
    | S1         | C2        |
    | S2         | C1        |
    | S3         | C3        |
    | S4         | C1        |
    +------------+-----------+


join
~~~~

    >>> from dinsd.op import join

Here is the straightforward ``join`` of the two tables above:

    >>> enrollment = join(is_enrolled_on, is_called)
    >>> print(display(enrollment, 'student_id', 'name', 'course_id'))
    +------------+----------+-----------+
    | student_id | name     | course_id |
    +------------+----------+-----------+
    | S1         | Anne     | C1        |
    | S1         | Anne     | C2        |
    | S2         | Boris    | C1        |
    | S3         | Cindy    | C3        |
    | S4         | Devinder | C1        |
    +------------+----------+-----------+

In *Tutorial D* the ``JOIN`` relational operator can be used both as a prefix
function and as a infix operator.  In Python we can't define new infix
operators, but we can override existing ones.  Since ``JOIN`` is, at base, the
logical ``and`` operator, it would make sense to override ``and`` for the
infix version of join.  However, we can't do that in Python, because ``and``
is a short circuit operator, whereas both arguments to a function must be
evaluated before the function can be called, and we can only override an
operator by defining a function.

What we can do, however, is override the arithmetic ``&`` operator:

    >>> j2 = is_enrolled_on & is_called
    >>> print(display(j2, 'student_id', 'name', 'course_id'))
    +------------+----------+-----------+
    | student_id | name     | course_id |
    +------------+----------+-----------+
    | S1         | Anne     | C1        |
    | S1         | Anne     | C2        |
    | S2         | Boris    | C1        |
    | S3         | Cindy    | C3        |
    | S4         | Devinder | C1        |
    +------------+----------+-----------+
    >>> enrollment == j2
    True

The above join discussion takes us up to figure 4.2 on page 89 of AITDM, for
those following along in the book :).

On page 93 there is a discussion of cases where we *can't* perform a join.  In
particular, if two tables have columns with the same name but different types,
we cannot join them:

    >>> class PermissiveIds(dbdef.Relation):
    ...     student_id = str
    ...     name = str
    >>> permissive_is_called = PermissiveIds(
    ...     ('student_id', 'name'),
    ...     ('S1', 'Anne'),
    ...     ('S2', 'Boris'),
    ...     )
    >>> permissive_is_called & is_enrolled_on   # doctest: +NORMALIZE_WHITESPACE
    Traceback (most recent call last):
        ...
    TypeError: Duplicate attribute name ('student_id') with different type
        (first: <class 'str'>, second: <class '__main__.SID'> found in joined
        relvars with type names <class '__main__.PermissiveIds'> and <class
        '__main__.IsEnrolledOn'>

An error like this in a multi-join also indicates in which argument the error
was detected:

    >>> join(is_enrolled_on, is_called,
    ...         permissive_is_called)         # doctest: +NORMALIZE_WHITESPACE
    Traceback (most recent call last):
        ...
    TypeError: Duplicate attribute name ('student_id') with different type
        (first: <class '__main__.SID'>, second: <class 'str'> found in joined
        relvars with type names <class 'dinsd.dbdef.join_course_id_name_student_id'>
        and <class '__main__.PermissiveIds'> (error detected while processing
        argument 2)

In this error message you also get a peak at the names that are used for the
automatically generated ``Relation`` types used for the ``join`` result: a
concatenation of ``join`` and the attribute names, separated by '_'s.

If we join with an empty relation, we get an empty relation:

    >>> no_student_names = IsCalled()
    >>> print(no_student_names & is_enrolled_on)
    +-----------+------+------------+
    | course_id | name | student_id |
    +-----------+------+------------+
    +-----------+------+------------+

Join is idempotent: if we join a relation to itself, or if we join a relation
to the result of a previous join involving that relation, we get back the
original join:

    >>> j = is_enrolled_on & is_called
    >>> j == j & j
    True
    >>> j == j & is_called
    True

Join is commutative:

    >>> is_enrolled_on & is_called == is_called & is_enrolled_on
    True

Join is associative:

    >>> last_year = IsEnrolledOn(
    ...         ('student_id', 'course_id'),
    ...         ('S1',         'C3'),
    ...         ('S5',         'C3'),
    ...         ('S3',         'C3'),
    ...         )
    >>> (is_enrolled_on & is_called) & last_year == (
    ...     is_enrolled_on & (is_called & last_year))
    True

We also define a monadic join to simply return the argument:

    >>> join(last_year) == last_year
    True


intersect
~~~~~~~~~

    >>> from dinsd.op import intersect

This is really a special case of ``join``: the case where all of the
attributes of the two relations being joined are the same.  It is
equivalent to the set-intersection of the two relations:

    >>> repeat_enrollment = intersect(is_enrolled_on, last_year)
    >>> print(display(repeat_enrollment, 'student_id', 'course_id'))
    +------------+-----------+
    | student_id | course_id |
    +------------+-----------+
    | S3         | C3        |
    +------------+-----------+
    >>> repeat_enrollment == is_enrolled_on & last_year
    True

There are two reasons to use ``intersect`` instead of ``join``.  The
first is that because the domain of operation is constrained, the
implementation may be faster.  The better reason to use it is that it
declares your intention to join two sets with the same attributes,
and will raise an error if the two sets do not have the same
attributes:

    >>> intersect(is_called, is_enrolled_on)
    Traceback (most recent call last):
        ...
    TypeError: Cannot take intersection of unlike relations


times
~~~~~

    >>> from dinsd.op import times

Another special case of ``join``.  I'm not as fond of this operator name, but
I can't think of a better one.  In this case, there are *no* attributes in
common between the two relations, and the result of the join is the Cartesian
product of the two sets of values.

Use cases for this are not common, so we won't even try to come up with a
sensible example:

    >>> class Foo(dbdef.Relation):
    ...     bar = str
    >>> foo = Foo(('bar',), ('fizz',), ('gin',))
    >>> print(times(last_year, foo))
    +------+-----------+------------+
    | bar  | course_id | student_id |
    +------+-----------+------------+
    | fizz | C3        | S1         |
    | fizz | C3        | S3         |
    | fizz | C3        | S5         |
    | gin  | C3        | S1         |
    | gin  | C3        | S3         |
    | gin  | C3        | S5         |
    +------+-----------+------------+

Here there is not likely to be any performance gain by using ``times``, but
the pedagogical value of getting an error if you try to ``times`` relations
that share columns is probably even more valuable.

    >>> times(is_called, last_year)
    Traceback (most recent call last):
        ...
    TypeError: Cannot multiply relations that share attributes

Like ``join``, ``intersect`` and ``times`` may be called with more than
two relations:

    >>> two_years_ago = IsEnrolledOn()
    >>> print(intersect(is_enrolled_on, last_year, two_years_ago))
    +-----------+------------+
    | course_id | student_id |
    +-----------+------------+
    +-----------+------------+
    >>> class Bar(dbdef.Relation):
    ...     foo = str
    >>> bar = Bar(('foo',), ('gin',), ('fiz',))
    >>> print(times(last_year, bar, foo))
    +------+-----------+-----+------------+
    | bar  | course_id | foo | student_id |
    +------+-----------+-----+------------+
    | fizz | C3        | fiz | S1         |
    | fizz | C3        | fiz | S3         |
    | fizz | C3        | fiz | S5         |
    | fizz | C3        | gin | S1         |
    | fizz | C3        | gin | S3         |
    | fizz | C3        | gin | S5         |
    | gin  | C3        | fiz | S1         |
    | gin  | C3        | fiz | S3         |
    | gin  | C3        | fiz | S5         |
    | gin  | C3        | gin | S1         |
    | gin  | C3        | gin | S3         |
    | gin  | C3        | gin | S5         |
    +------+-----------+-----+------------+


rename
~~~~~~

    >>> from dinsd.op import rename

This is operator is not one discussed in the original literature on the
relational algebra (according to AITDM), but is needed for certain logical
operations.  It allows us to construct a new relation that is identical to an
existing relation except that one or more of the attributes have different
names.  This is required in order to perform logical operations on relations
where we need to *not* treat the attributes as the same, even though they have
the same data in them (we'll an example of this below).

We can rename a single attribute:

    >>> sid_is_called = rename(is_called, student_id='sid')
    >>> print(display(sid_is_called, 'sid', 'name'))
    +-----+----------+
    | sid | name     |
    +-----+----------+
    | S1  | Anne     |
    | S2  | Boris    |
    | S3  | Cindy    |
    | S4  | Devinder |
    | S5  | Boris    |
    +-----+----------+

Or more than one attribute:

    >>> sid_is_called = rename(is_called, student_id='sid', name='called')
    >>> print(display(sid_is_called, 'sid', 'called'))
    +-----+----------+
    | sid | called   |
    +-----+----------+
    | S1  | Anne     |
    | S2  | Boris    |
    | S3  | Cindy    |
    | S4  | Devinder |
    | S5  | Boris    |
    +-----+----------+

We can't rename a non-existent attribute;

    >>> sid_is_called = rename(is_called, fred='called')
    Traceback (most recent call last):
        ...
    KeyError: 'fred'

We support the revised semantics of *Tutorial D* that allows attribute names
to be swapped in one call:

    >>> sid_is_called = rename(is_called, student_id='name',
    ...                                   name='student_id')
    >>> print(sid_is_called)
    +------+------------+
    | name | student_id |
    +------+------------+
    | S1   | Anne       |
    | S2   | Boris      |
    | S3   | Cindy      |
    | S4   | Devinder   |
    | S5   | Boris      |
    +------+------------+

Rename is a read-only operation, it does not modify the source relation:

    >>> sid_is_called == is_called
    False
    >>> print(display(is_called, 'student_id', 'name'))
    +------------+----------+
    | student_id | name     |
    +------------+----------+
    | S1         | Anne     |
    | S2         | Boris    |
    | S3         | Cindy    |
    | S4         | Devinder |
    | S5         | Boris    |
    +------------+----------+

Example 4.3 on page 98 of AITDM uses ``rename`` and ``join`` to discover all
pairs of students that share the same name:

    >>> shared_name = join(rename(is_called, student_id='sid1'),
    ...                    rename(is_called, student_id='sid2'))
    >>> print(display(shared_name, 'sid1', 'name', 'sid2'))
    +------+----------+------+
    | sid1 | name     | sid2 |
    +------+----------+------+
    | S1   | Anne     | S1   |
    | S2   | Boris    | S2   |
    | S2   | Boris    | S5   |
    | S3   | Cindy    | S3   |
    | S4   | Devinder | S4   |
    | S5   | Boris    | S2   |
    | S5   | Boris    | S5   |
    +------+----------+------+

This table doesn't quite look like the one on page 98.  We can fix that using
the 'sort' keyword of ``display``:

    >>> print(display(shared_name, 'sid1', 'name', 'sid2',
    ...                 sort=['name', 'sid1', 'sid2']))
    +------+----------+------+
    | sid1 | name     | sid2 |
    +------+----------+------+
    | S1   | Anne     | S1   |
    | S2   | Boris    | S2   |
    | S2   | Boris    | S5   |
    | S5   | Boris    | S2   |
    | S5   | Boris    | S5   |
    | S3   | Cindy    | S3   |
    | S4   | Devinder | S4   |
    +------+----------+------+


project
~~~~~~~

This is not an explicit named operator in *Tutorial D*, but an implicit one
arising from a particular syntax.  We do a similar thing in dinsd by
overriding the ``>>`` operator.  But we also provide the named operator,
because we have to have a name for our implementation so we might as well
expose it and thus allow it to be used in functional as well as operator
style.

    >>> from dinsd.op import project

``project`` takes as its argument a set of attribute names, and returns a
relation containing just those attributes (and the corresponding values):

    >>> sids = project(is_enrolled_on, {'student_id'})
    >>> sids == is_enrolled_on >> {'student_id'}
    True
    >>> print(sids)
    +------------+
    | student_id |
    +------------+
    | S1         |
    | S2         |
    | S3         |
    | S4         |
    +------------+

dinsd's version of *Tutorial D*'s "ALL BUT" syntax is to mark the set of
names as an inversion.  We do this with the ``all_but`` wrapper, and the
``<<`` operator does this automatically.

Following AITDT, we can write the student_id matching matching expression on
page 101 as follows, to get our equivalent of figure 4.7 from page 101:

    >>> same_name = join(rename(is_called, student_id='sid1'),
    ...                  rename(is_called, student_id='sid2')) << {'name'}
    >>> print(same_name)
    +------+------+
    | sid1 | sid2 |
    +------+------+
    | S1   | S1   |
    | S2   | S2   |
    | S2   | S5   |
    | S3   | S3   |
    | S4   | S4   |
    | S5   | S2   |
    | S5   | S5   |
    +------+------+

(There is no way to get that table to exactly match the one from the book,
since the order from the book appears to be some artifact of the *Tutorial D*
implementation.)

Here is the same thing using the functional notation:

    >>> from dinsd.op import all_but
    >>> same_name == project(shared_name, all_but({'name'}))
    True

Observe that an ``all_but`` projection of the empty set produces an identical
relation:

    >>> same_name << {} == same_name
    True

In dinsd this is explicitly *not* the same object that was passed in to
the operation:

    >>> same_name << {} is same_name
    False

Aside: we are being a bit loose with our Python data types here in order to
make this notation consistent.  This may or may not be a bad idea, but it
does seem natural.  Technically, ``{}`` is an empty *dictionary* not an
empty set.  Python's literal notation for an empty set is ``set()``.  But
we can easily interpret an empty dictionary as an empty set *in this
context*, and so we do.

And of course there are the error cases:

    >>> shared_name << {'foo'}
    Traceback (most recent call last):
        ...
    TypeError: Attribute list included invalid attributes: {'foo'}
    >>> shared_name >> {'foo'}
    Traceback (most recent call last):
        ...
    TypeError: Attribute list included invalid attributes: {'foo'}

The little exercise on page 102, splitting the joined enrollment table back
into is_enrolled_on and is_called, looks like this in dinsd:

    >>> is_enrolled_on_split = enrollment >> {'student_id', 'course_id'}
    >>> is_called_split = enrollment >> {'student_id', 'name'}
    >>> del enrollment

That is, whereas in *Tutorial D* you must go through the process of declaring
the variables and initializing them, in dinsd you just do the projection and
keep a pointer to it in the name of your choice.  This comparison isn't fair,
though because I'm ignoring the issue of persisting the database here, which
will add a few characters and one additional statement when we get to it.  I
think *Tutorial D* does the persistence automatically.  But more, we haven't
dealt with constraints at all yet, and establishing those for a table is a bit
more complicated than the above.

    >>> print(display(is_enrolled_on_split, 'student_id', 'course_id'))
    +------------+-----------+
    | student_id | course_id |
    +------------+-----------+
    | S1         | C1        |
    | S1         | C2        |
    | S2         | C1        |
    | S3         | C3        |
    | S4         | C1        |
    +------------+-----------+
    >>> print(display(is_called_split, 'student_id', 'name'))
    +------------+----------+
    | student_id | name     |
    +------------+----------+
    | S1         | Anne     |
    | S2         | Boris    |
    | S3         | Cindy    |
    | S4         | Devinder |
    +------------+----------+

``is_enrolled_on_split`` is identical to the original ``is_enrolled_on``
relation, but ``is_called`` is not, since the ``enrollment`` relation did not
include any entry for the student who was to enrolled in any courses:

    >>> is_enrolled_on_split == is_enrolled_on
    True
    >>> is_called_split == is_called
    False
    >>> len(is_called_split) == len(is_called) - 1
    True


Dum and Dee
~~~~~~~~~~~

Two relations have special meaning and are given names in *Tutorial D*:
``TABLE_DUM`` and ``TABLE_DEE``.  Because these names are a bit awkward (and
why are these called ``tables`` when everything else is a relation?), standard
practice has quickly become to refer to them as ``Dum`` (or ``DUM``) and
``Dee`` (``DEE``).  We prefer the dual case versions, in analogy to the Python
capitalization for the analogous logical constants``True`` and ``False``.

We define these constants, which are instances of an otherwise not too useful
``Relation`` named ``DumDee``, in the ``dbdef`` module:

    >>> from dinsd.dbdef import Dum, Dee

``Dum`` is a relation with no attributes and no values:

    >>> print(Dum)
    ++
    ||
    ++
    ++

``Dee`` is a relation with no attributes and exactly one value, that
being a row of degree zero:

    >>> print(Dee)
    ++
    ||
    ++
    ||
    ++

The boolean value of ``Dum`` is ``False``, while that of ``Dee`` is ``True``:

    >>> bool(Dum)
    False
    >>> bool(Dee)
    True

This follows both from the relational logic and from Python's own conventions:
``Dum`` has no rows (it is empty, and like an empty list it is ``False``),
while ``Dee`` has one row, and being non-empty is ``True``.

Given ``Dee`` and ``Dum``, we can now understand the results we get from
the edge cases of various relational operators.

    >>> is_called >> {} == Dee
    True
    >>> join() == intersect() == times() == Dee
    True

Note that unlike Python's ``True`` and ``False``, which are singletons, there
may be other relation instances equivalent to ``Dum`` and ``Dee`` besides the
two defined in ``dbdef``.  Conceptually they are the "same" relation, but in
Python object terms they may be different objects:

    >>> is_called >> {} is Dee
    False

As per the discussion on page 104, ``Dee`` is an identity value for the
``join`` operator.  And, again, in dinsd what is produced is an equivalent
relation, not an identity at the object level:

    >>> is_called & Dee == is_called
    True
    >>> is_called & Dee is is_called
    False


Rel
~~~

In contemplating the "use the tools introduced so far" solution to the
question posed at the start of section 4.7 of AITDT, I realized that there
is a need for being able to easily create a temporary relation.  *Tutorial D*
has syntax for doing this, but up to this point dinsd hasn't, though we
could have used it in a few examples up above.

So, the dinsd way of dynamically creating a relation definition and a single
instance of that definition at the same time is ``Rel``:

    >>> from dinsd.op import Rel
    >>> print(Rel(name=str, sid=SID)(('name', 'sid'), ('Boris', 'S1')))
    +-------+-----+
    | name  | sid |
    +-------+-----+
    | Boris | S1  |
    +-------+-----+

``Rel`` is essentially the ``lambda`` of relations:

    >>> namelist = Rel(name=str)
    >>> print(namelist(('name',), ('Boris',), ('Anne',)))
    +-------+
    | name  |
    +-------+
    | Anne  |
    | Boris |
    +-------+
    >>> print(namelist(('name',), ('Anne',), ('George',)))
    +--------+
    | name   |
    +--------+
    | Anne   |
    | George |
    +--------+

Now we can complete the "existing operators" version of the restriction
query at the start of 4.7:

    >>> print((is_called & Rel(name=str)(dict(name='Boris')))
    ...              >> {'student_id'})
    +------------+
    | student_id |
    +------------+
    | S2         |
    | S5         |
    +------------+


where
-----

I'm not convinced that ``where`` is actually a part of the relational
algebra, but there is no denying its usefulness.

    >>> from dinsd.op import where

Example 4.7 on page 105 looks like this:

    >>> print(where(is_called, lambda row: row.name == 'Boris'))
    +-------+------------+
    | name  | student_id |
    +-------+------------+
    | Boris | S2         |
    | Boris | S5         |
    +-------+------------+

It would be nice if there were some shorter shorthand than ``lambda`` for
providing the expression, but in Python there isn't.

Here is example 4.8 written in dinsd:

    >>> print(where(is_called, lambda row: row.name.startswith('B')))
    +-------+------------+
    | name  | student_id |
    +-------+------------+
    | Boris | S2         |
    | Boris | S5         |
    +-------+------------+

With Python, it is easy to make this a bit more interesting:

    >>> print(where(is_called, lambda row: row.name.startswith(('B', 'A'))))
    +-------+------------+
    | name  | student_id |
    +-------+------------+
    | Anne  | S1         |
    | Boris | S2         |
    | Boris | S5         |
    +-------+------------+

Here are the edge cases from the bottom of page 106:

    >>> where(is_called, lambda row: True) == is_called
    True
    >>> where(is_called, lambda row: False) == type(is_called)()
    True

And now we can further improve the problem of finding just those student_ids
that designate students with the same name (figure 4.8 on page 107):

    >>> x = join(rename(is_called, student_id='sid1'),
    ...          rename(is_called, student_id='sid2')) >> {'sid1', 'sid2'}
    >>> print(where(x, lambda row: row.sid1 != row.sid2))
    +------+------+
    | sid1 | sid2 |
    +------+------+
    | S2   | S5   |
    | S5   | S2   |
    +------+------+

And of course the final version has the obvious analog in dinsd:

    >>> print(where(x, lambda row: row.sid1 < row.sid2))
    +------+------+
    | sid1 | sid2 |
    +------+------+
    | S2   | S5   |
    +------+------+

I will observe here that I didn't just use the ``x`` intermediate variable to
provide for less repetition in the examples, but also because I prefer that
"coding" style.  Rather than a single grand expression, it seems clearer to me
to break a computation up into pieces, somewhat in the way a mathematical
paper will often say, "let x = <something>, then <expression involving x>".


extend
------

This operator allows us to create a new relation that extends an existing
relation by performing a computation on the attributes of the initial
relation.

    >>> from dinsd.op import extend

Here is the expression that results in the example in figure 4.10 on pages
109 and 109:

    >>> x = extend(is_called, initial=lambda row: row.name[0])
    >>> print(display(x, 'student_id', 'name', 'initial'))
    +------------+----------+---------+
    | student_id | name     | initial |
    +------------+----------+---------+
    | S1         | Anne     | A       |
    | S2         | Boris    | B       |
    | S3         | Cindy    | C       |
    | S4         | Devinder | D       |
    | S5         | Boris    | B       |
    +------------+----------+---------+

A null extension is an identity operation:

    >>> extend(is_called) == is_called
    True

More than one attribute may be computed in a single extend call:

    >>> x = extend(is_called, caps=lambda row: row.name.upper(),
    ...                       hello=lambda row: "hello")
    >>> print(display(x, 'student_id', 'name', 'caps', 'hello'))
    +------------+----------+----------+-------+
    | student_id | name     | caps     | hello |
    +------------+----------+----------+-------+
    | S1         | Anne     | ANNE     | hello |
    | S2         | Boris    | BORIS    | hello |
    | S3         | Cindy    | CINDY    | hello |
    | S4         | Devinder | DEVINDER | hello |
    | S5         | Boris    | BORIS    | hello |
    +------------+----------+----------+-------+

Unlike *Tutorial D*, we do not have a left to right evaluation order for
extension expressions, so extension expressions in dinsd may only refer to
attributes from the base relation, not any newly created attributes.  This is
a minor restriction, since it is simple enough (and often clearer) to write
multiple extension expressions in such a case.  It would also be possible to
relax this restriction by using (name, func) tuples or some inspect trickery
and doing the extension one attribute at a time, but this hardly seems worth
the effort for what is probably an infrequent use case.


union
~~~~~

In the relational algebra, ``union`` corresponds to the ``or`` logical
operator, but is restricted to being an operator on relations whose
types are equal.  dinsd, like *Tutorial D*, provides ``union`` both
as a function and as an operator.  In dinsd the operator is ``|``.

    >>> from dinsd.op import union

We compute example 4.9 on page 111 thusly:

    >>> x = where(is_called, lambda row: row.name == 'Devinder')
    >>> y = where(is_enrolled_on, lambda row: row.course_id == CID('C1'))
    >>> ex49 = x >> {'student_id'} | y >> {'student_id'}
    >>> ex49 == union(x >> {'student_id'}, y >> {'student_id'})
    True
    >>> print(ex49)
    +------------+
    | student_id |
    +------------+
    | S1         |
    | S2         |
    | S4         |
    +------------+

It is an error to try to form the union of relations of disparate types:

    >>> is_called | is_enrolled_on
    Traceback (most recent call last):
        ...
    TypeError: Union operands must of equal types

Union is commutative and associative:

    >>> x = x >> {'student_id'}
    >>> y = y >> {'student_id'}
    >>> x | y == y | x
    True
    >>> z = Rel(student_id=SID)({'student_id': 'S5'})
    >>> (x | y) | z == x | (y | z) == union(x, y, z)
    True

Union of a single relation, or a relation with itself, is that relation.

    >>> union(is_called) == union(is_called, is_called) == is_called
    True

The union of no relations is ``Dum``:

    >>> union() == Dum
    True

*Tutorial D* has the ability to return an empty union if you specify a
heading.  The closest equivalent in dinsd is to pass an empty relation defined
via ``Rel``:

    >>> print(union(Rel(name=str, student_id=SID)()))
    +------+------------+
    | name | student_id |
    +------+------------+
    +------+------------+

This is just the union of a single empty union.


notmatching
~~~~~~~~~~~

Although the name is a bit more awkward in dinsd than it is in *Tutorial D*,
we approximately follow the *Tutorial D* naming for this function.  Since
it is the more general of the two difference functions (``minus`` and
``notmatching``), we also provide it as the operator ``-``.

    >>> from dinsd.op import notmatching

Here is example 4.11 from page 115:

    >>> not_enrolled = notmatching(is_called, is_enrolled_on)
    >>> not_enrolled == is_called - is_enrolled_on
    True
    >>> print(not_enrolled)
    +-------+------------+
    | name  | student_id |
    +-------+------------+
    | Boris | S5         |
    +-------+------------+

Since we are using the '-' operator and the operation is also referred to as a
"semidiffernce", we will use the imprecise but convenient terminology
"subtract" for this operation.

If we subtract from an empty relation we get an empty relation.  On the other
hand, if we subtract an empty relation we get the original relation (we
subtract nothing).

    >>> type(is_called)() - is_enrolled_on == type(is_called)()
    True
    >>> is_called - type(is_enrolled_on)() == is_called
    True

If we subtract a relation that has no common attributes, then if that
relation is empty (no matching rows) we get back the original relation.
If, however, it is not empty, then by the relational rules *all* the
rows match, and we get back the empty relation.

    >>> is_called - Rel(foo=str)() == is_called
    True
    >>> is_called - Rel(foo=str)(dict(foo='bar')) == type(is_called)()
    True

It is an error for match columns with the same name to have different types.

    >>> is_called - Rel(student_id=str)()  # doctest: +NORMALIZE_WHITESPACE
    Traceback (most recent call last):
        ...
    TypeError: Duplicate attribute name ('student_id') with different type
        (first: <class '__main__.SID'>, second: <class 'str'> found in
         match relation (relation type names are <class '__main__.IsCalled'>
         and <class 'dinsd.dbdef.rel_student_id'>)

minus
~~~~~

The ``minus`` operator is a subset of ``notmatching``, where the two
relations must have exactly the same columns, meaning that only exact
matches are removed.

    >>> from dinsd.op import minus
    >>> anne = Rel(student_id=SID, name=str)(dict(student_id='S1', name='Anne'))
    >>> print(minus(is_called, anne))
    +----------+------------+
    | name     | student_id |
    +----------+------------+
    | Boris    | S2         |
    | Boris    | S5         |
    | Cindy    | S3         |
    | Devinder | S4         |
    +----------+------------+
    >>> minus(is_called, Rel(student_id=SID)())
    Traceback (most recent call last):
        ...
    TypeError: Relation types must match for minus operation


Chapter 4 Exercises
~~~~~~~~~~~~~~~~~~~

Just for fun (well, and to improve our test coverage), we'll do some of the
exercises from the end of chapter 4 in AITDT.  There won't be much if any
explanation here, just code.

Note that we still aren't dealing with keys or other constraints yet.

Exercise 2:

    >>> from datetime import date
    >>> class date_type(date):
    ...     def __new__(cls, value):
    ...         if isinstance(value, date):
    ...             return value
    ...         return super().__new__(cls, *value)
    >>> class Cust(dbdef.Relation):
    ...     c_no = str
    ...     discount = float
    >>> class Orders(dbdef.Relation):
    ...     o_no = str
    ...     c_no = str
    ...     date = date_type
    >>> class OrderItem(dbdef.Relation):
    ...     o_no = str
    ...     p_no = str
    ...     qty = int
    >>> class Product(dbdef.Relation):
    ...     p_no = str
    ...     unit_price = float
    >>> cust = Cust(
    ...         ('c_no', 'discount'),
    ...         ('0012', 10.0),
    ...         ('1001', 5.0),
    ...         ('5', 20.0),
    ...         )
    >>> orders = Orders(
    ...         ('o_no', 'c_no', 'date'),
    ...         ('0001', '0012', date(2012, 11, 4)),
    ...         ('0002', '0012', (2012, 11, 5)),
    ...         ('0003', '5', date(2012, 11, 3)),
    ...         )
    >>> order_items = OrderItem(
    ...         ('o_no', 'p_no', 'qty'),
    ...         ('0001', '20001', 2),
    ...         ('0001', '20002', 3),
    ...         ('0002', '20001', 7),
    ...         ('0003', '2201', 20),
    ...         )
    >>> products = Product(
    ...         ('p_no', 'unit_price'),
    ...         ('20001', 120.50),
    ...         ('20002', 12.75),
    ...         ('2201', 1000.00),
    ...         )
    >>> x = order_items & products & orders & cust
    >>> x = extend(x, price=lambda row: (
    ...         round(row.qty*row.unit_price*(1-row.discount/100), 2)))
    >>> x = x >> {'o_no', 'p_no', 'price'}
    >>> print(display(x, 'o_no', 'p_no', 'price'))
    +------+-------+---------+
    | o_no | p_no  | price   |
    +------+-------+---------+
    | 0001 | 20001 | 216.9   |
    | 0001 | 20002 | 34.43   |
    | 0002 | 20001 | 759.15  |
    | 0003 | 2201  | 16000.0 |
    +------+-------+---------+

Exercise 3:

    >>> class ExamMark(dbdef.Relation):
    ...     student_id = SID
    ...     course_id = CID
    ...     mark = int
    >>> exam_marks = ExamMark(
    ...     ('student_id', 'course_id', 'mark'),
    ...     ('S1',         'C1',        85),
    ...     ('S1',         'C2',        49),
    ...     ('S1',         'C3',        85),
    ...     ('S2',         'C1',        49),
    ...     ('S3',         'C3',        66),
    ...     ('S4',         'C1',        93),
    ...     )
    >>> x = rename(exam_marks, student_id='sid1', mark='mark1')
    >>> y = rename(exam_marks, student_id='sid2', mark='mark2')
    >>> pairs = where(x & y, lambda r: r.sid1 < r.sid2)
    >>> diff = extend(pairs, gap=lambda r: abs(r.mark1 - r.mark2))
    >>> diff_only = diff << {'mark1', 'mark2'}
    >>> print(display(diff_only, 'course_id', 'sid1', 'sid2', 'gap'))
    +-----------+------+------+-----+
    | course_id | sid1 | sid2 | gap |
    +-----------+------+------+-----+
    | C1        | S1   | S2   | 36  |
    | C1        | S1   | S4   | 8   |
    | C1        | S2   | S4   | 44  |
    | C3        | S1   | S3   | 19  |
    +-----------+------+------+-----+

Exercise 4:

    >>> is_called - Dee
    IsCalled(('name', 'student_id'))
    >>> is_called - Dum == is_called
    True
    >>> is_called - is_called
    IsCalled(('name', 'student_id'))
    >>> (is_called - is_called) - is_called
    IsCalled(('name', 'student_id'))
    >>> is_called - (is_called - is_called) == is_called
    True

``notmatching`` is neither commutative nor associative, which makes
using the ``-`` operator for it a bit dicey...but so very convenient.

Oh, and for completeness: ``rename`` can be written in terms of
``extend``:

    >>> x = rename(is_called, student_id='sid')
    >>> y = extend(is_called, sid=lambda r: r.student_id) << {'student_id'}
    >>> x == y
    True


mtching
~~~~~~~

Following along in Chapter 5, for completeness.  We already defined the
exam_marks relation instance in one of the problems above.  Now we'll
add courses.

    >>> class Course(dbdef.Relation):
    ...     course_id = CID
    ...     title = str
    >>> courses = Course(
    ...             ('course_id',   'title'),
    ...             ('C1',          'Database'),
    ...             ('C2',          'HCI'),
    ...             ('C3',          'Op systems'),
    ...             ('C4',          'Programming'),
    ...             )
    >>> print(courses)
    +-----------+-------------+
    | course_id | title       |
    +-----------+-------------+
    | C1        | Database    |
    | C2        | HCI         |
    | C3        | Op systems  |
    | C4        | Programming |
    +-----------+-------------+
    >>> print(display(exam_marks, 'student_id', 'course_id', 'mark'))
    +------------+-----------+------+
    | student_id | course_id | mark |
    +------------+-----------+------+
    | S1         | C1        | 85   |
    | S1         | C2        | 49   |
    | S1         | C3        | 85   |
    | S2         | C1        | 49   |
    | S3         | C3        | 66   |
    | S4         | C1        | 93   |
    +------------+-----------+------+

*Tutorial D*'s expression:

   ``( COURSE JOIN EXAM_MARK ) { ALL BUT StudentId, Mark }``

becomes the dinsd expression:

    >>> print((courses & exam_marks) << {'student_id', 'mark'})
    +-----------+------------+
    | course_id | title      |
    +-----------+------------+
    | C1        | Database   |
    | C2        | HCI        |
    | C3        | Op systems |
    +-----------+------------+

The ``matching`` relational operator encapsulates this (union plus
projecting away any columns obtained from the second relation):

    >>> from dinsd.op import matching
    >>> print(matching(courses, exam_marks))
    +-----------+------------+
    | course_id | title      |
    +-----------+------------+
    | C1        | Database   |
    | C2        | HCI        |
    | C3        | Op systems |
    +-----------+------------+

Although this is the opposite of ``notmatching`` in a relational sense,
it is not an intuitive match for ``+`` the way ``notmatching`` is for
``-``.  Hence we do not overload any Python operators for this relational
operator.

A match against an empty relation is empty:

    >>> matching(type(courses)(), courses)
    Course(('course_id', 'title'))

In the reverse of the case for ``notmatching``, if there are no common
attributes matching against an empty relation produces an empty relation,
while matching against a non-empty relation produces the original
relation:

    >>> matching(courses, Dum)
    Course(('course_id', 'title'))
    >>> matching(courses, Dee) == courses
    True

compose
~~~~~~~

    >>> from dinsd.op import compose

``compose`` joins its operands and then projects away the attributes
that the two relations have in common.

    >>> course_marks = compose(courses, exam_marks)
    >>> course_marks == (courses & exam_marks) << {'course_id'}
    True
    >>> print(display(course_marks, 'title', 'student_id', 'mark',
    ...                             sort=('student_id', 'title')))
    +------------+------------+------+
    | title      | student_id | mark |
    +------------+------------+------+
    | Database   | S1         | 85   |
    | HCI        | S1         | 49   |
    | Op systems | S1         | 85   |
    | Database   | S2         | 49   |
    | Op systems | S3         | 66   |
    | Database   | S4         | 93   |
    +------------+------------+------+

If there are no common attributes, ``compose`` is the same as ``join``:

    >>> r1 = Rel(foo=int, bar=int)(('foo', 'bar'), (1, 2), (3, 4))
    >>> r2 = Rel(bing=int, bang=int)(('bing', 'bang'), (5, 6), (7, 8))
    >>> join(r1, r2) == compose(r1, r2)
    True

Compose is commutative, but not associative:

    >>> compose(courses, exam_marks) == compose(exam_marks, courses)
    True
    >>> r = Rel(student_id=SID, marks=int, name=str)(
    ...             ('student_id', 'marks', 'name'),
    ...             ('S1',         30,      'Anne'),
    ...             ('S2',         20,      'Borris'))
    >>> c1 = compose(compose(is_called, r), exam_marks)
    >>> c2 = compose(is_called, compose(r, exam_marks))
    >>> c1 == c2
    False


Aggregate Operators
-------------------

Aggregate operators map from relations to scalers.  The results of aggregate
operators are well defined (and thus the operator is a true relational
aggregate operator) only if the diadic form of the operation (the "base
operation") is commutative and associative.  That is, the order of evaluation
must not matter, since the order in which the rows are accessed is arbitrary
and may change.

As an aside, although discussed earlier, ``display`` is technically an
aggregate operator:  its input is a relation and its result is a scaler (a
string).


len (count)
~~~~~~~~~~~

*Tutorial D* calls this operator ``COUNT``, but Python already has a function
for returning the number of rows in a relation: ``len``:

    >>> len(is_called)
    5
    >>> len(exam_marks)
    6

That last was example 5.1 on page 127.  Example 5.2, counting the number of
students with marks above 50:

    >>> len(where(exam_marks, lambda r: r.mark > 50) >> {'student_id'})
    3


compute
~~~~~~~

    >>> from dinsd.op import compute

``compute`` has no analog in *Tutorial D*.  All of the aggregate functions
in *Tutorial D* version 2 have the ability to use an arbitrary expression
to compute a value over each row of the relation being aggregated.
``compute`` is the dinsd function that performs this computation operation.
It is an iterator (specifically a generator) the produces the computed
values one by one, which the individual aggregate operators then consume.
Since the corresponding Python functions can consume iterators, this means
that most of dinsd's aggregation operators are vanilla Python functions
applied to a ``compute`` value.

``compute`` takes a relation and a function of one argument.  The function
is passed each row of the relation in turn, and the result of the function
applied to that row is yielded as the next value of the iterator.

For example, we can extract the scores from the ``mark`` column of the
``exam_marks`` table like this:

    >>> sorted(compute(exam_marks, lambda r: r.mark))
    [49, 49, 66, 85, 85, 93]

The call to ``sorted`` here does two things:  it consumes all of the values
from the compute generator, and it gives the returned values a predictable
order so that the result can be used as part of the doctest.


column
~~~~~~

``compute`` provides completely general expressions for dinsd.  But it is
wordy and awkward when dealing with common cases, so dinsd also provides some
shorthand functions.  The single most common case is obtaining the values of
one or more columns.  This feature is provided by the ``column`` function:

    >>> from dinsd.op import column

We use the term column rather than the relationally correct term attribute
because in this case we are conceptually operating on entire columns for the
purpose of extracting them from the relation and aggregating them; so, they
are no longer relation attributes, they are extracted columns of data.

``column`` takes a relation and one or more attribute names as arguments.  If
one attribute name is given, the resulting iterator yields the values of that
attribute.  If more than one is given, the iterator yields a tuple of the
attributes, each tuple having the values in the same order as the order in
which the names are specified in the ``column`` argument list:

    >>> sorted(column(exam_marks, 'mark'))
    [49, 49, 66, 85, 85, 93]
    >>> sorted(column(exam_marks, 'student_id', 'mark'))  # doctest: +NORMALIZE_WHITESPACE
    [(SID('S1'), 49), (SID('S1'), 85), (SID('S1'), 85), (SID('S2'), 49),
     (SID('S3'), 66), (SID('S4'), 93)]


sum
~~~

The Python ``sum`` function can be used to "sum" any values that support
addition.  The result will be a valid relational aggregation if and only if
the addition operation is both associative and commutative.

Arithmetic addition satisfies this criteria.  Here is AITDT's example 5.3 in
dinsd:

    >>> sum(column(where(exam_marks, lambda r: r.student_id == SID('S1')),
    ...            'mark'))
    219

String concatenation does not, so while the expression:

    sum(column(exam_marks, 'title'))

will produce a result, it will be neither a useful result nor a valid
relational aggregation result.

Python's ``sum`` operator returns the correct result when passed a column
from an empty relation:

    >>> sum(column(Rel(foo=int)(), 'foo'))
    0


max and min
~~~~~~~~~~~

Like ``sum``, the Python ``max`` and ``min`` functions accept interators
as in put, so we can use them directly to compute the corresponding
relational max and min:

    >>> max(column(where(exam_marks, lambda r: r.student_id == SID('S1')),
    ...            'mark'))
    85
    >>> min(column(where(exam_marks, lambda r: r.student_id == SID('S1')),
    ...            'mark'))
    49

``min`` and ``max`` do not have defined results on an empty relation:

    >>> min(column(Rel(foo=int)(), 'foo'))
    Traceback (most recent call last):
        ...
    ValueError: min() arg is an empty sequence


Other Aggregate Operators
~~~~~~~~~~~~~~~~~~~~~~~~~

Python doesn't have a function that corresponds directly to the *Tutorial D*
``AVG`` function, and it is a bit tricky to define it as a function that takes
a single iterator (that does not support ``len``, which compute does not) as
its argument, so dinsd provides the ``avg`` function in the ``op`` module.

    >>> from dinsd.op import avg
    >>> round(avg(column(exam_marks, 'mark')), 2)
    71.17
    >>> avg(column(Rel(foo=int)({'foo': 3}), 'foo'))
    3.0
    >>> avg(column(Rel(foo=int)(), 'foo'))
    0

The Python/dinsd version of the *Tutorial D* ``AND`` and ``OR`` operators are
named ``all`` and ``any``, respectively.


summarize
~~~~~~~~~

It will take us a bit to get to the ``summarize`` operator, since we are following
along with the examples in AITDT.

Here is a dinsd expression to computes the table in figure 5.4 on page 130 of
AITDT, the number of students that have sat for an exam in each course:

    >>> x = extend(courses >> {'course_id'},
    ...            n=lambda r: len(where(exam_marks,
    ...                                  lambda x: x.course_id==r.course_id
    ...                                 ) >> {'student_id'}))
    >>> print(x)
    +-----------+---+
    | course_id | n |
    +-----------+---+
    | C1        | 3 |
    | C2        | 1 |
    | C3        | 2 |
    | C4        | 0 |
    +-----------+---+

But that is getting ahead of the text.  Here is the dinsd expression I naively
came up with to compute the table in figure 5.5:

    >>> x = extend(courses, exam_result=lambda r:
    ...         project(
    ...             where(exam_marks,
    ...                   lambda x: x.course_id==r.course_id),
    ...              {'student_id', 'mark'})) << {'title'}
    >>> print(x)
    +-----------+-----------------------+
    | course_id | exam_result           |
    +-----------+-----------------------+
    | C1        | +------+------------+ |
    |           | | mark | student_id | |
    |           | +------+------------+ |
    |           | | 49   | S2         | |
    |           | | 85   | S1         | |
    |           | | 93   | S4         | |
    |           | +------+------------+ |
    |           |                       |
    | C2        | +------+------------+ |
    |           | | mark | student_id | |
    |           | +------+------------+ |
    |           | | 49   | S1         | |
    |           | +------+------------+ |
    |           |                       |
    | C3        | +------+------------+ |
    |           | | mark | student_id | |
    |           | +------+------------+ |
    |           | | 66   | S3         | |
    |           | | 85   | S1         | |
    |           | +------+------------+ |
    |           |                       |
    | C4        | +------+------------+ |
    |           | | mark | student_id | |
    |           | +------+------------+ |
    |           | +------+------------+ |
    |           |                       |
    +-----------+-----------------------+

You will note that we have no way to control the print order of the subtables,
so they come out in the default sorted order.  It would be possible to extend
display to support column and sort specifications for attributes of the main
table, but the complexity is not warranted by the minimal use that such a
facility would be likely to get.

Here is the simpler, direct equivalent of the expression used for this table
in the AITDT example 5.6:

    >>> x == extend(courses >> {'course_id'}, exam_result=lambda r:
    ...          compose(Rel(course_id=CID)({'course_id': r.course_id}),
    ...                  exam_marks))
    True

Having successfully written first expression above, and successfully
translated example 5.6, I have to admit that I had no clue what AITDT's
example 5.7 was doing.  After reading the explanation and thinking about it I
believe he uses that more complicated expression because *Tutorial D* version
one did not have a general expression facility for aggregate operators.

We can compute the average exam mark instead, as in example 5.8, as follows:

    >>> av = extend(exam_marks >> {'course_id'}, avg_mark=lambda r:
    ...         round(avg(column(where(exam_marks,
    ...             lambda x: x.course_id==r.course_id), 'mark')), 2))
    >>> print(display(av, 'course_id', 'avg_mark'))
    +-----------+----------+
    | course_id | avg_mark |
    +-----------+----------+
    | C1        | 75.67    |
    | C2        | 49.0     |
    | C3        | 75.5     |
    +-----------+----------+

The relation being extended changes to exam_marks here so that we only
have rows for exams that had marks.  AITDT notes that if we had continued
to use courses we'd end up with a division by zero for the course with
no marks.  The dinsd average function returns ``0`` for an empty list,
so the dinsd version of this expression would not blow up:

    >>> x = extend(courses >> {'course_id'},
    ...            avg_mark=lambda r:
    ...                round(avg(column(where(exam_marks,
    ...                                   lambda x: x.course_id==r.course_id),
    ...                          'mark')), 2))
    >>> print(display(x, 'course_id', 'avg_mark'))
    +-----------+----------+
    | course_id | avg_mark |
    +-----------+----------+
    | C1        | 75.67    |
    | C2        | 49.0     |
    | C3        | 75.5     |
    | C4        | 0.0      |
    +-----------+----------+

Also take note that my convention of using intermediate variables to simplify
complex expressions is exactly reason AITDT uses the *Tutorial D* ``WITH``
expression in these examples.  In this case I chose to only split it for
printing, but if we follow the pattern from AITDT more closely we end up
with this:

    >>> c_er2 = extend(exam_marks >> {'course_id'},
    ...          exam_result=lambda r:
    ...             compose(Rel(course_id=CID)({'course_id': r.course_id}),
    ...                     exam_marks))
    >>> x = extend(c_er2, avg_mark=lambda r:
    ...          round(avg(column(r.exam_result, 'mark')), 2))
    >>> x = x << {'exam_result'}
    >>> x == av
    True

At least, I think that's what the AITDT example is doing.  In the examples
above you can see several different wrapping styles attempting to make the
expressions readable, but when the lambda expressions get long there is really
no good way to do it.

But in Python, we can also use temporary variables to hold lambda expressions:

    >>> r_cid = Rel(course_id=CID)
    >>> c_er = lambda r: compose(r_cid({'course_id': r.course_id}), exam_marks)
    >>> x = extend(exam_marks >> {'course_id'}, exam_result=c_er)
    >>> c_avg = lambda r: round(avg(column(r.exam_result, 'mark')), 2)
    >>> x = extend(x, avg_mark=c_avg) << {'exam_result'}
    >>> x == av
    True

That's a bit easier to follow, I think.  It is interesting that I felt the
need to resort to Hungarian Notation for the relation and lambda variables.
It seems like there is an irreducible minimum of complexity in relational
algebra expressions.

Now we finally get to ``summarize`` itself, which is designed to make the
above complex expressions simpler and easier to understand.  The basic idea is
that the pattern of composing with a row containing data from one table to
obtain a list of matching data from another table (which could be the same
table) and then aggregating over that extracted data is very common.  So we
have an operator that expresses that more compactly:

    >>> from dinsd.op import summarize
    >>> print(summarize(exam_marks, courses >> {'course_id'},
    ...               n=lambda r: len(r)))
    +-----------+---+
    | course_id | n |
    +-----------+---+
    | C1        | 3 |
    | C2        | 1 |
    | C3        | 2 |
    | C4        | 0 |
    +-----------+---+

Keep in mind that the summarize lambda is being passed the *relation* that the
summarize computes, not a row.

The above formulation corresponds to the *Tutorial D* ``SUMMARIZE PER``
construct.  The dinsd equivalent of *Tutorial D*'s ``SUMMARIZE BY`` looks
almost exactly the same, except that the second argument is a set of attribute
names, instead of a relation.  Those names are used to project the main
relation for composition with itself.  We used that pattern in the average
computation:

    >>> av == summarize(exam_marks, {'course_id'},
    ...                avg_mark=lambda r: round(avg(column(r, 'mark')), 2))
    True

Definitely a worthwhile simplification.

Because debugging a summarization can be tricky without being able to see the
data computed by the compose, ``summarize`` supports a special boolean keyword
argument ``_deubg``.  If set to ``True``, the intermediate table extended with
the composed data is printed to stdout:

    >>> x =summarize(exam_marks, {'course_id'}, _debug=True,
    ...              avg_mark=lambda r: round(avg(column(r, 'mark')), 2))
    +-----------+-----------------------+
    | course_id | t_e_m_p               |
    +-----------+-----------------------+
    | C1        | +------+------------+ |
    |           | | mark | student_id | |
    |           | +------+------------+ |
    |           | | 49   | S2         | |
    |           | | 85   | S1         | |
    |           | | 93   | S4         | |
    |           | +------+------------+ |
    |           |                       |
    | C2        | +------+------------+ |
    |           | | mark | student_id | |
    |           | +------+------------+ |
    |           | | 49   | S1         | |
    |           | +------+------------+ |
    |           |                       |
    | C3        | +------+------------+ |
    |           | | mark | student_id | |
    |           | +------+------------+ |
    |           | | 66   | S3         | |
    |           | | 85   | S1         | |
    |           | +------+------------+ |
    |           |                       |
    +-----------+-----------------------+

Summarize can take any number of new column computations functions:

    >>> x = summarize(exam_marks, {'course_id'},
    ...               attendees=lambda r: len(r),
    ...               avg_mark=lambda r: round(avg(column(r, 'mark')), 2))
    >>> print(display(x, 'course_id', 'attendees', 'avg_mark'))
    +-----------+-----------+----------+
    | course_id | attendees | avg_mark |
    +-----------+-----------+----------+
    | C1        | 3         | 75.67    |
    | C2        | 1         | 49.0     |
    | C3        | 2         | 75.5     |
    +-----------+-----------+----------+


group
-----

    >>> from dinsd.op import group

``group`` encapsulates the ``extend``/``compose`` sub-operation of summarize:

    >>> results = group(exam_marks, exam_results={'student_id', 'mark'})
    >>> print(results)
    +-----------+-----------------------+
    | course_id | exam_results          |
    +-----------+-----------------------+
    | C1        | +------+------------+ |
    |           | | mark | student_id | |
    |           | +------+------------+ |
    |           | | 49   | S2         | |
    |           | | 85   | S1         | |
    |           | | 93   | S4         | |
    |           | +------+------------+ |
    |           |                       |
    | C2        | +------+------------+ |
    |           | | mark | student_id | |
    |           | +------+------------+ |
    |           | | 49   | S1         | |
    |           | +------+------------+ |
    |           |                       |
    | C3        | +------+------------+ |
    |           | | mark | student_id | |
    |           | +------+------------+ |
    |           | | 66   | S3         | |
    |           | | 85   | S1         | |
    |           | +------+------------+ |
    |           |                       |
    +-----------+-----------------------+

Since the grouping specification is a attribute name set, we can also use
the ``all_but`` wrapper with it:

    >>> results == group(exam_marks, exam_results=all_but({'course_id'}))
    True

The grouping refers implicitly to both the set of columns being grouped and
the set of columns not being grouped.  This leads to an ambiguity as to which
columns are involved if there are multiple grouping specifications.  Rather
than trying to sort this out and greatly complicating the implementation for
little practical benefit, the group function only accepts one new column name:

    >>> group(exam_marks, res1={'marks'}, res2={'student_id'})
    Traceback (most recent call last):
        ...
    TypeError: Only one new column may be specified for grouping

In this we follow *Tutorial D*, which dropped support for multiple grouping
columns in Version 2.

It is an error to try to group on a non-existent column:

    >>> group(exam_marks, foo={'bar'})
    Traceback (most recent call last):
        ...
    TypeError: Attribute list included invalid attributes: {'bar'}

Grouping on no attributes produces a column consisting of instances of
``Dee``:

    >>> print(group(exam_marks, foo={}))
    +-----------+-----+------+------------+
    | course_id | foo | mark | student_id |
    +-----------+-----+------+------------+
    | C1        | ++  | 49   | S2         |
    |           | ||  |      |            |
    |           | ++  |      |            |
    |           | ||  |      |            |
    |           | ++  |      |            |
    |           |     |      |            |
    | C1        | ++  | 85   | S1         |
    |           | ||  |      |            |
    |           | ++  |      |            |
    |           | ||  |      |            |
    |           | ++  |      |            |
    |           |     |      |            |
    | C1        | ++  | 93   | S4         |
    |           | ||  |      |            |
    |           | ++  |      |            |
    |           | ||  |      |            |
    |           | ++  |      |            |
    |           |     |      |            |
    | C2        | ++  | 49   | S1         |
    |           | ||  |      |            |
    |           | ++  |      |            |
    |           | ||  |      |            |
    |           | ++  |      |            |
    |           |     |      |            |
    | C3        | ++  | 66   | S3         |
    |           | ||  |      |            |
    |           | ++  |      |            |
    |           | ||  |      |            |
    |           | ++  |      |            |
    |           |     |      |            |
    | C3        | ++  | 85   | S1         |
    |           | ||  |      |            |
    |           | ++  |      |            |
    |           | ||  |      |            |
    |           | ++  |      |            |
    |           |     |      |            |
    +-----------+-----+------+------------+

Grouping on *all* of the attributes, on the other hand, produces a relation
with a single attribute, whose single value is the original relation:

    >>> print(group(exam_marks, foo=all_but({})))
    +-----------------------------------+
    | foo                               |
    +-----------------------------------+
    | +-----------+------+------------+ |
    | | course_id | mark | student_id | |
    | +-----------+------+------------+ |
    | | C1        | 49   | S2         | |
    | | C1        | 85   | S1         | |
    | | C1        | 93   | S4         | |
    | | C2        | 49   | S1         | |
    | | C3        | 66   | S3         | |
    | | C3        | 85   | S1         | |
    | +-----------+------+------------+ |
    |                                   |
    +-----------------------------------+


ungroup
-------

    >>> from dinsd.op import ungroup

``ungroup`` effectively undoes what ``group`` does:

    >>> ungroup(results, 'exam_results') == exam_marks
    True

dinsd also supports doing ``ungroup`` via its formal definition (see
page 141 of AITDT):

    >>> t_func = lambda r: times(r.exam_results,
    ...                          type(results)(r) << {'exam_results'})
    >>> exam_marks == union(column(extend(results, t=t_func), 't'))
    True

This works because if ``union`` is passed a single argument consisting of a
non-``Relation`` iterator, it does the union of all the relations returned by
that iterator.  That is, it acts as an aggregation function.  The built-in
``ungroup`` is more efficient, though.

It is an error to pass ``ungroup`` a column not in the relation:

    >>> ungroup(results, 'foo')
    Traceback (most recent call last):
        ...
    KeyError: 'foo'

The column specified must of course be a relation valued attribute:

    >>> ungroup(results, 'course_id')
    Traceback (most recent call last):
        ...
    AttributeError: 'CID' object has no attribute 'header'


wrap
----

Example 5.14 shows how to turn attribute data into tuples as an attribute
value.  dinsd's row objects aren't exposed as standalone classes, but they are
readily available using the ``row`` attribute of a relation.  So we can
write the dinsd equivalent of 5.14 as follows:

    >>> contact_info = Rel(name=str, house=str, street=str, city=str, zip=str)(
    ...                     ('name',  'house', 'street',  'city',   'zip'),
    ...                     ('Anne',  '120',   'Peach',   'London', '00111'),
    ...                     ('Boris', '5',     'Rose',    'Kiev',   '00112'))
    >>> sub_rel = type(contact_info << {'name'})
    >>> row_func = lambda r: sub_rel.row(dict(house=r.house, street=r.street,
    ...                                       city=r.city, zip=r.zip))
    >>> x = extend(contact_info, address=row_func) << {'house', 'street',
    ...                                                'city', 'zip'}
    >>> print(display(x, 'name', 'address'))
    +-------+---------------------------------------------------+
    | name  | address                                           |
    +-------+---------------------------------------------------+
    | Anne  | (city=London, house=120, street=Peach, zip=00111) |
    | Boris | (city=Kiev, house=5, street=Rose, zip=00112)      |
    +-------+---------------------------------------------------+



About the Name
--------------

When I started dinsd, I knew there was no way I could fully implement
TTM's *D* in Python.  But I wanted something very like *D*.  Given that I was
implementing *D* in Python, I figured I should use the name of some character
that had something to do with the letter D, and Dinsdale immediately came to
mind.  However, since my program was not going to be a full D, I decided I'd
shorten the name to indicate it was only a partial thing.  This also served to
make it a more uniquely searchable term.  I contemplated both 'dins' and
'dinsd', settling on the latter because it had two Ds in it.

After a bit I realized that I was developing something closer to the true
spirit of *D* than I had initially thought I'd be able to manage, but still
something that did not conform to TTM.  It occurred to me that 'dinsd' could
almost, but not quite, be interpreted as "D Is Not D", and I briefly
considered changing the name to disnd.  That's a lot harder to pronounce,
though.

And then it occured to me that the big difference between my (non-conformant)
implementation of *D* and a real *D* is that Python does not have compile
time, static typing.  And thus the real acronym behind the name dinsd was
revealed:

    D Is Not Static D

It isn't really quite *D* in a few other details as well, but that's the big
one.
