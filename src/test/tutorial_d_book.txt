Disnd and An Introduction to Relational Database Theory
=======================================================


Introduction
------------

Dinsd was initially developed while I went through the book

    An Introduction to Relational Database Theory
    by Hugh Darwen

This book uses his and C. J. Date's notional ``D`` implementation, *Tutorial
D*, and gives various examples and problems based on *Tutorial D* to elucidate
the concepts of Relational Algebra.  ``D`` and *Tutorial D* are in turn
defined fully in Hugh and C. J.'s seminal work

    The Third Manifesto

This file writes out various examples in dinsd that correspond to examples
and/or problems from the book, as well as other examples that were inspired by
the book or explored during the writing of dinsd.  The examples here do not
particularly follow the book, as writing the implementation required hoping
around a bit in the conceptual space, but the general pattern does follow
the book.

Where reference is made to specific page numbers or figures in AIRTD, this is
based on the bookboon.com edition of the book as available for download on
November 1st, 2012.

This file contains blocks of tests that are meant to exercise edge cases as
well as the primary test cases and examples, because it is the test document
that I used as I was building the system.  It is, therefore, a cross between a
design document, a literate test document, and a detailed discussion of the
system mechanics.  It may not be the best possible introduction to dinsd, but
if you can make your way through it you will have a fairly deep understanding
of dinsd and its relationship to TTM and its correspondence (or lack thereof)
to *Tutorial D*.


Scalars, Rows, and Relations (and a Few Words About Databases)
--------------------------------------------------------------

Databases and Terminology
~~~~~~~~~~~~~~~~~~~~~~~~~

The concept of a database holding a set of relations is central to *Tutorial
D*, but the process for defining a database is only introduced implicitly.  We
will do the same, talking about the conceptual framework of the database,
but defer the discussion of the syntax for defining one until later.

A database in dinsd consists of a container for the database, and a name and
definition for all of the relations that are stored in the container.  This is
what is usually called a "schema" in SQL.  Dinsd refers to it as a "DBDef"
(Database Definition).  Unlike a traditional SQL DBMS, dinsd does not store
the ``DBDef`` "in the catalog"; instead the Python program holds the
``DBDef``, and only the data is stored in the persistent store.  This means
that dnsd is not by itself a DBMS...in order to have a dinsd based DBMS, you
would need to write an application that would manage ``DBDef`` definitions as
data objects, and persist them.  While this is conceptually possible, it is
not something I need for the first intended application of dinsd and so is not
addressed here.

The facilities for defining databases and relations are provided by the dinsd
module ``dbdef``.

    >>> from dinsd import dbdef

A database is a set of relations.  Per TTM and AIRDT, a relation consists of a
header plus a set of ``tuples`` that conform to that header.  Since Python
already uses the term ``tuple`` to refer to a different concept, we will fall
back to the less precise but more widely recognized term ``row``.  I'm sure
the authors of TTM would/will be annoyed by this, but it is less confusing
than trying to reuse the world ``tuple`` in a Python context.

So, a relation consists of a name and a header.  The header consists of a list
of attributes, with each attribute having a type.


Types, User Defined Types, and Scalars
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Python is strictly typed.  Defining new types in Python is very simple:  you
define a class.  (Classes are, in fact, of type ``type`` in Python).  So, to
define the type for an attribute, we need a class that is that type.  For
standard types (``int``, ``str``, etc), we can use the Python built in types.
For what TTM calls "user defined types", we define a new class.

In order to maintain consistency, every user defined scaler type (ie:
non-relation type) used with dinsd must conform to the common syntax and
semantics of the Python built in types:  the type constructor at a minimum
accepts one argument, and either raises an error if the argument (the
"selector" in TTM/AIRDT terms) cannot be converted into a valid instance of
the type, or a valid instance of the type if it can be.  In Python terms, this
means that the class's ``__init__`` method must accept at least one positional
argument.  (For the purposes of dinsd, this argument should always be present,
even if it is optional in the class definition for other reasons.)

It is also critical that, like the Python built in types, the user defined
type accept an instance of itself as a valid selector, and return an
equivalent instance.  (Note that this requirement is not true for *Tutorial
D*.  We'll discuss why it is true for dinsd below.)

In addition to the conformance checking in the ``__init__`` method, there are
some auxiliary methods that every user defined scaler type must have.
Therefore dinsd provides a base type for such user defines scalers, named
``Scaler``.  A simple ``Scaler`` type must always store its value in an attribute
named ``value``.

There is nothing preventing an application from defining a type without using
``Scaler`` as the superclass, or using ``Scaler`` and implementing a more
complex value store, but if an application does so it is responsible for
correctly implementing the equivalents of all of the methods that ``Scaler``
provides.  Specifically, it must provide all the methods to define a total
ordering of the values, as required by TTM.

So, we can now define the ``SID`` and ``CID`` types that are introduced in
chapter 2 of AIRDT:

    >>> class ID(dbdef.Scaler):
    ...
    ...     def __init__(self, id):
    ...         if isinstance(id, self.__class__):
    ...             self.value = id.value
    ...             return
    ...         if not isinstance(id, str):
    ...             raise TypeError(
    ...                 "Expected str but passed {}".format(type(id)))
    ...         if (2 <= len(id) <=4 and id.startswith(self.firstchar) and
    ...                 id[1:].isdigit()):
    ...             self.value = id
    ...         else:
    ...             raise TypeError("Expected '{}' followed by one to "
    ...                             "three digits".format(self.firstchar))
    ...
    >>> class SID(ID):
    ...     firstchar = 'S'
    ...
    >>> class CID(ID):
    ...     firstchar = 'C'

This definition corresponds to example 2.4 on page 47 of AIRDT.  It looks
somewhat more complicated, but this is primarily because defining the error
messages resulting from "selection" failure, whereas example 2.4 is leaving
those error messages to be automatically generated by the *Tutorial D* system.

Semantically the examples are equivalent.  We are using Python built
in functions for the checks, whereas in *Tutorial D* the check functions are
user defined (and their definition is deferred to later in the book).
The *Tutorial D* ``C CHAR`` declaration corresponds to our ``self.value =
id``, with the difference that our self.value is not typed.  The *value* has a
type, which our code is constraining to be ``str`` (Python's equivalent
of *Tutorial D*'s ``CHAR``), but as is normal in Python the name we store it
under is not itself typed.

To prove that this (straightforward Python) implementation is correct:

    >>> SID('S1')
    SID('S1')
    >>> CID('C1')
    CID('C1')
    >>> SID(SID('S1'))
    SID('S1')
    >>> print(SID('S2'))
    S2
    >>> SID('1')
    Traceback (most recent call last):
        ...
    TypeError: Expected 'S' followed by one to three digits
    >>> CID(1)
    Traceback (most recent call last):
        ...
    TypeError: Expected str but passed <class 'int'>
    >>> SID('C1')
    Traceback (most recent call last):
        ...
    TypeError: Expected 'S' followed by one to three digits
    >>> CID('C0003')
    Traceback (most recent call last):
        ...
    TypeError: Expected 'C' followed by one to three digits
    >>> SID(CID('C1'))
    Traceback (most recent call last):
        ...
    TypeError: Expected str but passed <class '__main__.CID'>
    >>> SID('S1') == SID('S1')
    True
    >>> SID('S1') != CID('C1')
    True
    >>> SID('S2') == SID(SID('S2'))
    True
    >>> SID('S1') < SID('S2')
    True
    >>> CID('C7') >= CID('C7')
    True
    >>> SID('S1') > CID('C2')
    Traceback (most recent call last):
        ...
    TypeError: unorderable types: SID() > CID()


Defining and Instantiating Relations
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

A relation in dinsd is also a class, which is nice because in TTM it is also a
type, making this consistent between TTM and dinsd/Python.  As mentioned
above, for a relation, the class (type) definition consists of a list of
attributes and their types.

We will demonstrate this by defining the example relation used throughout the
first couple chapters of AIRDT.  This corresponds to the  *Tutorial D* type
definition that is given on page 42 of AIRDT.

    >>> class IsEnrolledOn(dbdef.Relation):
    ...     student_id = SID
    ...     name = str
    ...     course_id = CID

Because relations share a common semantic, we don't need to define an explicit
``__init__`` function.  All ``Relation`` types automatically have an
``__init__`` method that allows us to construct a relation (relvar) of that
type by providing data to extend the relation.

The most verbose and most general way of creating such a relation instance is
as follows:

    >>> is_enrolled_on = IsEnrolledOn(
    ...     IsEnrolledOn._row_({'student_id': SID('S1'), 'course_id': CID('C1'), 'name': 'Anne'}),
    ...     IsEnrolledOn._row_({'student_id': SID('S1'), 'course_id': CID('C2'), 'name': 'Anne'}),
    ...     IsEnrolledOn._row_({'student_id': SID('S2'), 'course_id': CID('C1'), 'name': 'Boris'}),
    ...     IsEnrolledOn._row_({'student_id': SID('S3'), 'course_id': CID('C3'), 'name': 'Cindy'}),
    ...     IsEnrolledOn._row_({'student_id': SID('S4'), 'course_id': CID('C1'), 'name': 'Devinder'}),
    ...     )

This corresponds directly to the relation definition in example 2.3 on page
45.  As I indicated earlier, we are using the term ``row`` instead of the term
``tuple`` to avoid confusion with the Python ``tuple`` type.

You may wonder about the odd (at least to Python eyes) method name '_row_'.  A
relation must be able to hold attributes with any "normal" name...we do not
want there to be an "reserved" identifiers the way there are in some SQL
dialects.  So any valid Python identifier is a valid attribute name...except
ones that start with '_'.  We can thus use names that start with '_' as the
names of non-relation-attribute attributes of the Python class.  However, the
normal Python convention is that names that start with a single '_' are
"private" names, and not part of the API.  In order to distinguish dinsd
method names that *are* part of the API, we also suffix the name with a '_'.
Thus, attribute identifiers in dinsd that both start and end with a '_'
are *methods* that are part of the public API.

If you compare the above "relation literal" with the one from example 2.3 in
AIRDT, you might notice a major difference between disnd and *Tutorial D*, one
of the ones that makes dinsd not technically compatible with TTM.  In TTM
(and *Tutorial D*) a type is completely characterized by the names of the
attributes and the types of the values.  If two definitions or two literals
refer to the *same* set of names, with the value associated with each name
having the *same* type, then the two are considered to be *exactly* the same
type for all purposes.  Python, on the other hand, bases type identity on the
identity of the *object* that defines the type.  Thus in our version of the
Relation literal above, we must explicitly name the type that we are
instantiating, so that Python can follow the pointer to the single type object
that defines this Relation type.  While this technically violates TTM, in
practice we allow relvars that have conformant types in the TTM sense to fully
interoperate.  Thus in practice the difference has a consequence only in the
way in which Relations and Tuples are created, and not on the way in which
they are used.

You will also note that dinsd does not provide any direct syntax for defining
a row independent of any Relation, unlike *Tutorial D*, which provides the
TUPLE keyword for both type and literal definition.  In disd a row selector
function is accessible only from the corresponding `Relation` type that uses
the same header.  This also does not fully conform to TTM, but I haven't
found a need to define a row without also defining the corresponding Relation,
so I don't think it is a significant omission.

The instantiation above is *very* wordy.  Given that in dinsd we know which
type of relation we are instantiating, we can provide usefully simpler
representations.

First, we know that the body of the relation is a list of rows, so there is no
need to pass in explicitly constructed rows.  Instead, if the init method is
passed a simple Python dictionary, it can do the conversion-to-row itself:

    >>> is_enrolled_on2 = IsEnrolledOn(
    ...     {'student_id': SID('S1'), 'course_id': CID('C1'), 'name': 'Anne'},
    ...     {'student_id': SID('S1'), 'course_id': CID('C2'), 'name': 'Anne'},
    ...     {'student_id': SID('S2'), 'course_id': CID('C1'), 'name': 'Boris'},
    ...     {'student_id': SID('S3'), 'course_id': CID('C3'), 'name': 'Cindy'},
    ...     {'student_id': SID('S4'), 'course_id': CID('C1'), 'name': 'Devinder'},
    ...     )

Second, by relaxing from the purity of never using ordered tuples we can
significantly reduce the typing required to enter a relation literal:

    >>> is_enrolled_on3 = IsEnrolledOn(
    ...     ('student_id', 'course_id', 'name'),
    ...     (SID('S1'), CID('C1'), 'Anne'),
    ...     (SID('S1'), CID('C2'), 'Anne'),
    ...     (SID('S2'), CID('C1'), 'Boris'),
    ...     (SID('S3'), CID('C3'), 'Cindy'),
    ...     (SID('S4'), CID('C1'), 'Devinder'),
    ...     )

Here the ``__init__`` method sees that it is being passed (Python) tuples
instead of dictionaries, and takes the first such tuple as the ordered list
of attributes and each subsequent tuple as a correspondingly ordered list
of attribute values.

Finally, by taking advantage of the fact that we know the type of the
attributes and have access to the selector function for that type, we can
produce a minimally simple representation by not requiring the type of the
attribute value to explicitly specified in the literal:

    >>> is_enrolled_on4 = IsEnrolledOn(
    ...     ('student_id', 'course_id', 'name'),
    ...     ('S1', 'C1', 'Anne'),
    ...     ('S1', 'C2', 'Anne'),
    ...     ('S2', 'C1', 'Boris'),
    ...     ('S3', 'C3', 'Cindy'),
    ...     ('S4', 'C1', 'Devinder'),
    ...     )

There is no loss of type-safety here, since each selector is passed through
the type constructor, which will raise an error if the argument value does
not conform to the selector.

You can see now why it is critical that the type constructor accept an
instance of itself as valid:  the relation constructor will always pass the
value of an attribute through the corresponding type function for validation,
and an instance of that type must be reported as valid.

It might appear as though there is another step of simplification we could do:
not require the first tuple of attribute names, but instead assume the same
ordering as that used in the relation definition.  Although it would
technically be possible to do this in Python (by using an ``OrderedDict`` for
the Relation class dictionary) it is not a natural fit for normal Python
semantics, and would (unlike, I believe, the previous simplifications)
definitely violate the spirit of TTM by making the meaning of a relation
literal dependent on the order of definition of the attributes in the relation
definition.  In contrast, the final simplification above is not dependent on
the definition order, only on the types, which cannot change.

So, in dinsd you can choose the level of correspondence to the *Tutorial D*
literal notation that you prefer.  All of the above representations produce
the same relvar value:

    >>> is_enrolled_on == is_enrolled_on2 == is_enrolled_on3 == is_enrolled_on4
    True

It's ``repr`` is one of the more compact version of the literal representation:

    >>> is_enrolled_on     # doctest: +NORMALIZE_WHITESPACE
    IsEnrolledOn(('course_id', 'name',    'student_id'),
                   (CID('C1'), 'Anne',     SID('S1')),
                   (CID('C1'), 'Boris',    SID('S2')),
                   (CID('C1'), 'Devinder', SID('S4')),
                   (CID('C2'), 'Anne',     SID('S1')),
                   (CID('C3'), 'Cindy',    SID('S3')))

Of course, the real repr is a single line and so is not as pretty as the
example makes it look.  We've lined up the example so that you can notice that
the attributes are sorted alphabetically, and the rows are sorted according to
their values as tuples.  We could also just allow them to be in their
"natural" order, but in Python that is semi-random and it is more convenient
to have a consistent ordering in the representation.

The ``str`` (printed) representation is likewise sorted, but is in a more
convenient format for inspecting the relation:

    >>> print(is_enrolled_on)
    +-----------+----------+------------+
    | course_id | name     | student_id |
    +-----------+----------+------------+
    | C1        | Anne     | S1         |
    | C1        | Boris    | S2         |
    | C1        | Devinder | S4         |
    | C2        | Anne     | S1         |
    | C3        | Cindy    | S3         |
    +-----------+----------+------------+

Testing the Edges
~~~~~~~~~~~~~~~~~

So much for the basics and the simple initial example from AIRDT Chapter 2.
Let's take a look at some edge cases to make sure the code handles them.

First of all, we can create an empty Relation:

    >>> is_enrolled_on = IsEnrolledOn()
    >>> is_enrolled_on
    IsEnrolledOn(('course_id', 'name', 'student_id'))
    >>> print(is_enrolled_on)
    +-----------+------+------------+
    | course_id | name | student_id |
    +-----------+------+------------+
    +-----------+------+------------+

The dictionary passed to the _row_ constructor must have the right number of
values:

    >>> IsEnrolledOn._row_({})
    Traceback (most recent call last):
        ...
    TypeError: Expected 3 attributes, got 0
    >>> IsEnrolledOn._row_({'student_id': 'S1', 'name': 'foo'})
    Traceback (most recent call last):
        ...
    TypeError: Expected 3 attributes, got 2
    >>> IsEnrolledOn._row_({'student_id': 'S1', 'name': 'foo',
    ...                         'course_id': 'C1', 'bar': 1})
    Traceback (most recent call last):
        ...
    TypeError: Expected 3 attributes, got 4

And the attribute names must match those defined in the relation:

    >>> IsEnrolledOn._row_({'student_id': 'S1', 'name': 'foo', 'bad': 1})
    Traceback (most recent call last):
        ...
    TypeError: Invalid attribute name bad

The values must be valid:

    >>> IsEnrolledOn._row_({'student_id': 'S1', # doctest: +NORMALIZE_WHITESPACE
    ...                      'name': 'foo', 'course_id': 1})
    Traceback (most recent call last):
        ...
    TypeError: Expected str but passed <class 'int'>, 1 invalid for attribute course_id
    >>> IsEnrolledOn._row_({'student_id': 'S1', # doctest: +NORMALIZE_WHITESPACE
    ...                     'name': 'foo', 'course_id': 'S1'})
    Traceback (most recent call last):
        ...
    TypeError: Expected 'C' followed by one to three digits, 'S1' invalid
         for attribute course_id

But it is OK to use the selector form ('C1') rather than the full scaler
value form (CID('C1')):

    >>> r = IsEnrolledOn._row_(
    ...         {'student_id': 'S1', 'name': 'foo', 'course_id': 'C1'})

A row also has a distinct ``repr`` and ``str``:

    >>> r                       # doctest: +NORMALIZE_WHITESPACE
    IsEnrolledOn._row_({'course_id': CID('C1'), 'name': 'foo', 'student_id':
                        SID('S1')})
    >>> print(r)
    (course_id=C1, name=foo, student_id=S1)

You will note that as with the ``repr``  and ``str`` of a ``Relation``, the
``repr`` and ``str`` of a ``row`` is sorted by the attribute names.  The
``str`` representation of a ``row`` is not nearly as useful as that of
a ``Relation``, but is provided for completeness.

The same type checking happens when instantiating a Relation using the
shorthand, and additionally reports which row is in error:

    >>> IsEnrolledOn(('course_id', 'name'),
    ...               ('S1', 'Anne'))
    Traceback (most recent call last):
        ...
    TypeError: Expected 3 attributes, got 2 in header row
    >>> IsEnrolledOn(('course_id', 'name', 'student_id'),
    ...               ('C1', 'Anne'))
    Traceback (most recent call last):
        ...
    TypeError: Expected 3 attributes, got 2 in row 1
    >>> IsEnrolledOn(('course_id', 'name', 'student_id'),
    ...               ('C1', 'Anne', 'S1'),
    ...               ('C2', 'Anne', 'S1', 'foo'),
    ...               )
    Traceback (most recent call last):
        ...
    TypeError: Expected 3 attributes, got 4 in row 2
    >>> IsEnrolledOn(('course_id', 'name', 'foo'),
    ...               ('C1', 'Anne', 'S1'),
    ...               )
    Traceback (most recent call last):
        ...
    AttributeError: 'IsEnrolledOn' object has no attribute 'foo'
    >>> IsEnrolledOn(                   # doctest: +NORMALIZE_WHITESPACE
    ...               ('course_id', 'name', 'student_id'),
    ...               ('C1', 'Anne', 'S1'),
    ...               ('C2', 'Anne', 'C1'),
    ...               )
    Traceback (most recent call last):
        ...
    TypeError: Expected 'S' followed by one to three digits, 'C1' invalid for
        attribute student_id in row 2



Relational Operators
--------------------

Analogous to how the classes used for defining row and relation types are
collected into the dinsd ``dbdef`` namespace, the methods used to define
various relational operators are defined in their own namespace, in this case
named ``op``.  It is annoying to type ``op.`` in front of the operators,
though, since we type them much more often than the dbdef class names.
So we'll import each operator at the start of the section discussing it.


Example Relations
~~~~~~~~~~~~~~~~~

Here are the two relations used in the examples in Chapter 4 of AIRDT:

    >>> class IsCalled(dbdef.Relation):
    ...     student_id = SID
    ...     name = str
    >>> is_called = IsCalled(
    ...     ('student_id',  'name'),
    ...     ('S1',          'Anne'),
    ...     ('S2',          'Boris'),
    ...     ('S3',          'Cindy'),
    ...     ('S4',          'Devinder'),
    ...     ('S5',          'Boris'),
    ...     )
    >>> print(is_called)
    +----------+------------+
    | name     | student_id |
    +----------+------------+
    | Anne     | S1         |
    | Boris    | S2         |
    | Boris    | S5         |
    | Cindy    | S3         |
    | Devinder | S4         |
    +----------+------------+
    >>> class IsEnrolledOn(dbdef.Relation):
    ...     student_id = SID
    ...     course_id = CID
    >>> is_enrolled_on = IsEnrolledOn(
    ...     ('student_id',  'course_id'),
    ...     ('S1',          'C1'),
    ...     ('S1',          'C2'),
    ...     ('S2',          'C1'),
    ...     ('S3',          'C3'),
    ...     ('S4',          'C1'),
    ...     )
    >>> print(is_enrolled_on)
    +-----------+------------+
    | course_id | student_id |
    +-----------+------------+
    | C1        | S1         |
    | C1        | S2         |
    | C1        | S4         |
    | C2        | S1         |
    | C3        | S3         |
    +-----------+------------+

Here we have changed the meaning of the names IsEnrolledOn and is_enrolled_on.
We would not be allowed to do this in *Tutorial D* or *TTM* without first
declaring variables as discarded and *then* defining new types for them.
Python sees that as pointless busywork and does not require it, but it is one
of the things that makes dinsd not TTM compliant.  (We will see later,
however, that disd *does* implement semi-statically-typed relvars inside
databases.)

Python keeps track of objects by pointer, though, not by name, so to Python
the type of the relation pointed to now by is_enrolled_on is different from
the type of the relation pointed to by the old is_enrolled_on variables, even
though the two relation types have the same identifier:

    >>> type(is_enrolled_on).__name__ == type(is_enrolled_on2).__name__
    True
    >>> type(is_enrolled_on) == type(is_enrolled_on2)
    False

That is, Python is *strongly typed*, even though it is also *dynamically
typed*.  (In fact, if you consider that it is really the object that is typed,
and that there are no real 'variables' in Python, just names that contain
references to objects, disnd probably does technically comply with TTM...but
not with its spirit, which requires static typing.)


display
~~~~~~~

``display`` is not a relational algebra function, but we introduce it here
because it is useful in the examples, and it is located in the ``op``
namespace.

    >>> from dinsd.op import display

The value returned by ``display`` is very similar to the value returned
by turning a relation in to a string, except that we can control the
order of the columns in the resulting table display.  Using ``display``
we can print the relations in the same column order that is used in AITDM:

    >>> print(display(is_called, 'student_id', 'name'))
    +------------+----------+
    | student_id | name     |
    +------------+----------+
    | S1         | Anne     |
    | S2         | Boris    |
    | S3         | Cindy    |
    | S4         | Devinder |
    | S5         | Boris    |
    +------------+----------+
    >>> print(display(is_enrolled_on, 'student_id', 'course_id'))
    +------------+-----------+
    | student_id | course_id |
    +------------+-----------+
    | S1         | C1        |
    | S1         | C2        |
    | S2         | C1        |
    | S3         | C3        |
    | S4         | C1        |
    +------------+-----------+


join
~~~~

    >>> from dinsd.op import join

Here is the straightforward ``join`` of the two tables above:

    >>> enrollment = join(is_enrolled_on, is_called)
    >>> print(display(enrollment, 'student_id', 'name', 'course_id'))
    +------------+----------+-----------+
    | student_id | name     | course_id |
    +------------+----------+-----------+
    | S1         | Anne     | C1        |
    | S1         | Anne     | C2        |
    | S2         | Boris    | C1        |
    | S3         | Cindy    | C3        |
    | S4         | Devinder | C1        |
    +------------+----------+-----------+

In *Tutorial D* the ``JOIN`` relational operator can be used both as a prefix
function and as a infix operator.  In Python we can't define new infix
operators, but we can override existing ones.  Since ``JOIN`` is, at base, the
logical ``and`` operator, it would make sense to override ``and`` for the
infix version of join.  However, we can't do that in Python, because ``and``
is a short circuit operator, whereas both arguments to a function must be
evaluated before the function can be called, and we can only override an
operator by defining a function.

What we can do, however, is override the arithmetic ``&`` operator:

    >>> j2 = is_enrolled_on & is_called
    >>> print(display(j2, 'student_id', 'name', 'course_id'))
    +------------+----------+-----------+
    | student_id | name     | course_id |
    +------------+----------+-----------+
    | S1         | Anne     | C1        |
    | S1         | Anne     | C2        |
    | S2         | Boris    | C1        |
    | S3         | Cindy    | C3        |
    | S4         | Devinder | C1        |
    +------------+----------+-----------+
    >>> enrollment == j2
    True

The above join discussion takes us up to figure 4.2 on page 89 of AITDM, for
those following along in the book :).

On page 93 there is a discussion of cases where we *can't* perform a join.  In
particular, if two tables have columns with the same name but different types,
we cannot join them:

    >>> class PermissiveIds(dbdef.Relation):
    ...     student_id = str
    ...     name = str
    >>> permissive_is_called = PermissiveIds(
    ...     ('student_id', 'name'),
    ...     ('S1', 'Anne'),
    ...     ('S2', 'Boris'),
    ...     )
    >>> permissive_is_called & is_enrolled_on   # doctest: +NORMALIZE_WHITESPACE
    Traceback (most recent call last):
        ...
    TypeError: Duplicate attribute name ('student_id') with different type
        (first: <class 'str'>, second: <class '__main__.SID'> found in joined
        relvars with type names <class '__main__.PermissiveIds'> and <class
        '__main__.IsEnrolledOn'>

An error like this in a multi-join also indicates in which argument the error
was detected:

    >>> join(is_enrolled_on, is_called,
    ...         permissive_is_called)         # doctest: +NORMALIZE_WHITESPACE
    Traceback (most recent call last):
        ...
    TypeError: Duplicate attribute name ('student_id') with different type
        (first: <class '__main__.SID'>, second: <class 'str'> found in joined
        relvars with type names <class 'dinsd.dbdef.join_course_id_name_student_id'>
        and <class '__main__.PermissiveIds'> (error detected while processing
        argument 2)

In this error message you also get a peak at the names that are used for the
automatically generated ``Relation`` types used for the ``join`` result: a
concatenation of ``join`` and the attribute names, separated by '_'s.

If we join with an empty relation, we get an empty relation:

    >>> no_student_names = IsCalled()
    >>> print(no_student_names & is_enrolled_on)
    +-----------+------+------------+
    | course_id | name | student_id |
    +-----------+------+------------+
    +-----------+------+------------+

Join is idempotent: if we join a relation to itself, or if we join a relation
to the result of a previous join involving that relation, we get back the
original join:

    >>> j = is_enrolled_on & is_called
    >>> j == j & j
    True
    >>> j == j & is_called
    True

Join is commutative:

    >>> is_enrolled_on & is_called == is_called & is_enrolled_on
    True

Join is associative:

    >>> last_year = IsEnrolledOn(
    ...         ('student_id', 'course_id'),
    ...         ('S1',         'C3'),
    ...         ('S5',         'C3'),
    ...         ('S3',         'C3'),
    ...         )
    >>> (is_enrolled_on & is_called) & last_year == (
    ...     is_enrolled_on & (is_called & last_year))
    True

We also define a monadic join to simply return the argument:

    >>> join(last_year) == last_year
    True


intersect
~~~~~~~~~

    >>> from dinsd.op import intersect

This is really a special case of ``join``: the case where all of the
attributes of the two relations being joined are the same.  It is
equivalent to the set-intersection of the two relations:

    >>> repeat_enrollment = intersect(is_enrolled_on, last_year)
    >>> print(display(repeat_enrollment, 'student_id', 'course_id'))
    +------------+-----------+
    | student_id | course_id |
    +------------+-----------+
    | S3         | C3        |
    +------------+-----------+
    >>> repeat_enrollment == is_enrolled_on & last_year
    True

There are two reasons to use ``intersect`` instead of ``join``.  The
first is that because the domain of operation is constrained, the
implementation may be faster.  The better reason to use it is that it
declares your intention to join two sets with the same attributes,
and will raise an error if the two sets do not have the same
attributes:

    >>> intersect(is_called, is_enrolled_on)
    Traceback (most recent call last):
        ...
    TypeError: Cannot take intersection of unlike relations


times
~~~~~

    >>> from dinsd.op import times

Another special case of ``join``.  I'm not as fond of this operator name, but
I can't think of a better one.  In this case, there are *no* attributes in
common between the two relations, and the result of the join is the Cartesian
product of the two sets of values.

Use cases for this are not common, so we won't even try to come up with a
sensible example:

    >>> class Foo(dbdef.Relation):
    ...     bar = str
    >>> foo = Foo(('bar',), ('fizz',), ('gin',))
    >>> print(times(last_year, foo))
    +------+-----------+------------+
    | bar  | course_id | student_id |
    +------+-----------+------------+
    | fizz | C3        | S1         |
    | fizz | C3        | S3         |
    | fizz | C3        | S5         |
    | gin  | C3        | S1         |
    | gin  | C3        | S3         |
    | gin  | C3        | S5         |
    +------+-----------+------------+

Here there is not likely to be any performance gain by using ``times``, but
the pedagogical value of getting an error if you try to ``times`` relations
that share columns is probably even more valuable.

    >>> times(is_called, last_year)
    Traceback (most recent call last):
        ...
    TypeError: Cannot multiply relations that share attributes

Like ``join``, ``intersect`` and ``times`` may be called with more than
two relations:

    >>> two_years_ago = IsEnrolledOn()
    >>> print(intersect(is_enrolled_on, last_year, two_years_ago))
    +-----------+------------+
    | course_id | student_id |
    +-----------+------------+
    +-----------+------------+
    >>> class Bar(dbdef.Relation):
    ...     foo = str
    >>> bar = Bar(('foo',), ('gin',), ('fiz',))
    >>> print(times(last_year, bar, foo))
    +------+-----------+-----+------------+
    | bar  | course_id | foo | student_id |
    +------+-----------+-----+------------+
    | fizz | C3        | fiz | S1         |
    | fizz | C3        | fiz | S3         |
    | fizz | C3        | fiz | S5         |
    | fizz | C3        | gin | S1         |
    | fizz | C3        | gin | S3         |
    | fizz | C3        | gin | S5         |
    | gin  | C3        | fiz | S1         |
    | gin  | C3        | fiz | S3         |
    | gin  | C3        | fiz | S5         |
    | gin  | C3        | gin | S1         |
    | gin  | C3        | gin | S3         |
    | gin  | C3        | gin | S5         |
    +------+-----------+-----+------------+


rename
~~~~~~

    >>> from dinsd.op import rename

This is operator is not one discussed in the original literature on the
relational algebra (according to AITDM), but is needed for certain logical
operations.  It allows us to construct a new relation that is identical to an
existing relation except that one or more of the attributes have different
names.  This is required in order to perform logical operations on relations
where we need to *not* treat the attributes as the same, even though they have
the same data in them (we'll an example of this below).

We can rename a single attribute:

    >>> sid_is_called = rename(is_called, student_id='sid')
    >>> print(display(sid_is_called, 'sid', 'name'))
    +-----+----------+
    | sid | name     |
    +-----+----------+
    | S1  | Anne     |
    | S2  | Boris    |
    | S3  | Cindy    |
    | S4  | Devinder |
    | S5  | Boris    |
    +-----+----------+

Or more than one attribute:

    >>> sid_is_called = rename(is_called, student_id='sid', name='called')
    >>> print(display(sid_is_called, 'sid', 'called'))
    +-----+----------+
    | sid | called   |
    +-----+----------+
    | S1  | Anne     |
    | S2  | Boris    |
    | S3  | Cindy    |
    | S4  | Devinder |
    | S5  | Boris    |
    +-----+----------+

We can't rename a non-existent attribute;

    >>> sid_is_called = rename(is_called, fred='called')
    Traceback (most recent call last):
        ...
    KeyError: 'fred'

We support the revised semantics of *Tutorial D* that allows attribute names
to be swapped in one call:

    >>> sid_is_called = rename(is_called, student_id='name',
    ...                                   name='student_id')
    >>> print(sid_is_called)
    +------+------------+
    | name | student_id |
    +------+------------+
    | S1   | Anne       |
    | S2   | Boris      |
    | S3   | Cindy      |
    | S4   | Devinder   |
    | S5   | Boris      |
    +------+------------+

Rename is a read-only operation, it does not modify the source relation:

    >>> sid_is_called == is_called
    False
    >>> print(display(is_called, 'student_id', 'name'))
    +------------+----------+
    | student_id | name     |
    +------------+----------+
    | S1         | Anne     |
    | S2         | Boris    |
    | S3         | Cindy    |
    | S4         | Devinder |
    | S5         | Boris    |
    +------------+----------+

Example 4.3 on page 98 of AITDM uses ``rename`` and ``join`` to discover all
pairs of students that share the same name:

    >>> shared_name = join(rename(is_called, student_id='sid1'),
    ...                    rename(is_called, student_id='sid2'))
    >>> print(display(shared_name, 'sid1', 'name', 'sid2'))
    +------+----------+------+
    | sid1 | name     | sid2 |
    +------+----------+------+
    | S1   | Anne     | S1   |
    | S2   | Boris    | S2   |
    | S2   | Boris    | S5   |
    | S3   | Cindy    | S3   |
    | S4   | Devinder | S4   |
    | S5   | Boris    | S2   |
    | S5   | Boris    | S5   |
    +------+----------+------+

This table doesn't quite look like the one on page 98.  We can fix that using
the 'sort' keyword of ``display``:

    >>> print(display(shared_name, 'sid1', 'name', 'sid2',
    ...                 sort=['name', 'sid1', 'sid2']))
    +------+----------+------+
    | sid1 | name     | sid2 |
    +------+----------+------+
    | S1   | Anne     | S1   |
    | S2   | Boris    | S2   |
    | S2   | Boris    | S5   |
    | S5   | Boris    | S2   |
    | S5   | Boris    | S5   |
    | S3   | Cindy    | S3   |
    | S4   | Devinder | S4   |
    +------+----------+------+


project
~~~~~~~

This is not an explicit named operator in *Tutorial D*, but an implicit one
arising from a particular syntax.  Just because we can, we do a similar thing
in dinsd by overriding the ``>>`` operator.  But we also provide the named
operator, because we have to have a name for our implementation so we might as
well expose it and thus be consistent.  (I thought about using just the named
operator with the attribute names as regular arguments, but I like the idea
that the syntax we actually use makes it clear that the attribute names are a
set, not an ordered list...unlike the case for, say, the ``display``
function.  On the other hand, the shift syntax is candy and not really needed).

    >>> from dinsd.op import project

``project`` takes as its argument a set of attribute names, and returns a
relation containing just those attributes (and the corresponding values):

    >>> sids = project(is_enrolled_on, {'student_id'})
    >>> sids == is_enrolled_on >> {'student_id'}
    True
    >>> print(sids)
    +------------+
    | student_id |
    +------------+
    | S1         |
    | S2         |
    | S3         |
    | S4         |
    +------------+

We can't use *Tutorial D*'s "ALL BUT" syntax...our version of that is the
``<<`` operator, implemented by the 'all_but' keyword of the ``project``
function.  Following AITDT, we can write the student_id matching matching
expression on page 101 as follows, to get our equivalent of figure 4.7 from
page 101:

    >>> same_name = join(rename(is_called, student_id='sid1'),
    ...                  rename(is_called, student_id='sid2')) << {'name'}
    >>> print(same_name)
    +------+------+
    | sid1 | sid2 |
    +------+------+
    | S1   | S1   |
    | S2   | S2   |
    | S2   | S5   |
    | S3   | S3   |
    | S4   | S4   |
    | S5   | S2   |
    | S5   | S5   |
    +------+------+

(There is no way to get that table to exactly match the one from the book,
since the order from the book appears to be some artifact of the *Tutorial D*
implementation.)

For completeness:

    >>> same_name == project(shared_name, all_but={'name'})
    True

Observe that an ``all_but`` projection of the empty set produces an identical
relation:

    >>> same_name << {} == same_name
    True

In dinsd this is explicitly *not* the same object that was passed in to
the operation:

    >>> same_name << {} is same_name
    False

And of course there are the error cases:

    >>> shared_name << {'foo'}
    Traceback (most recent call last):
        ...
    KeyError: 'foo'
    >>> shared_name >> {'foo'}
    Traceback (most recent call last):
        ...
    TypeError: Attribute list included invalid attributes: {'foo'}

The little exercise on page 102, splitting the joined enrollment table back
into is_enrolled_on and is_called, looks like this in dinsd:

    >>> is_enrolled_on_split = enrollment >> {'student_id', 'course_id'}
    >>> is_called_split = enrollment >> {'student_id', 'name'}
    >>> del enrollment

That is, whereas in *Tutorial D* you must go through the process of declaring
the variables and initializing them, in dinsd you just do the projection and
keep a pointer to it in the name of your choice.  This comparison isn't fair,
though because I'm ignoring the issue of persisting the database here, which
will add a few characters and one additional statement when we get to it.  I
think *Tutorial D* does the persistence automatically.  But more, we haven't
dealt with constraints at all yet, and establishing those for a table is a bit
more complicated than the above.

    >>> print(display(is_enrolled_on_split, 'student_id', 'course_id'))
    +------------+-----------+
    | student_id | course_id |
    +------------+-----------+
    | S1         | C1        |
    | S1         | C2        |
    | S2         | C1        |
    | S3         | C3        |
    | S4         | C1        |
    +------------+-----------+
    >>> print(display(is_called_split, 'student_id', 'name'))
    +------------+----------+
    | student_id | name     |
    +------------+----------+
    | S1         | Anne     |
    | S2         | Boris    |
    | S3         | Cindy    |
    | S4         | Devinder |
    +------------+----------+

``is_enrolled_on_split`` is identical to the original ``is_enrolled_on``
relation, but ``is_called`` is not, since the ``enrollment`` relation did not
include any entry for the student who was to enrolled in any courses:

    >>> is_enrolled_on_split == is_enrolled_on
    True
    >>> is_called_split == is_called
    False
    >>> len(is_called_split) == len(is_called) - 1
    True


Dum and Dee
~~~~~~~~~~~

Two relations have special meaning and are given names in *Tutorial D*:
``TABLE_DUM`` and ``TABLE_DEE``.  Because these names are a bit awkward (and
why are these called ``tables`` when everything else is a relation?), standard
practice has quickly become to refer to them as ``Dum`` (or ``DUM``) and
``Dee`` (``DEE``).  We prefer the dual case versions, in analogy to the Python
capitalization for the analogous logical constants``True`` and ``False``.

We define these constants, which are instances of an otherwise not too useful
``Relation`` named ``DumDee``, in the ``dbdef`` module:

    >>> from dinsd.dbdef import Dum, Dee

``Dum`` is a relation with no attributes and no values:

    >>> print(Dum)
    ++
    ||
    ++
    ++

``Dee`` is a relation with no attributes and exactly one value, that
being a row of degree zero:

    >>> print(Dee)
    ++
    ||
    ++
    ||
    ++

The boolean value of ``Dum`` is ``False``, while that of ``Dee`` is ``True``:

    >>> bool(Dum)
    False
    >>> bool(Dee)
    True

This follows both from the relational logic and from Python's own conventions:
``Dum`` has no rows (it is empty, and like an empty list it is ``False``),
while ``Dee`` has one row, and being non-empty is ``True``.

Given ``Dee`` and ``Dum``, we can now understand the results we get from
the edge cases of various relational operators.

    >>> is_called >> {} == Dee
    True
    >>> join() == intersect() == times() == Dee
    True

Note that unlike Python's ``True`` and ``False``, which are singletons, there
may be other relation instances equivalent to ``Dum`` and ``Dee`` besides the
two defined in ``dbdef``.  Conceptually they are the "same" relation, but in
Python object terms they may be different objects:

    >>> is_called >> {} is Dee
    False

As per the discussion on page 104, ``Dee`` is an identity value for the
``join`` operator.  And, again, in dinsd what is produced is an equivalent
relation, not an identity at the object level:

    >>> is_called & Dee == is_called
    True
    >>> is_called & Dee is is_called
    False


Rel
~~~

In contemplating the "use the tools introduced so far" solution to the
question posed at the start of section 4.7 of AITDT, I realized that there
is a need for being able to easily create a temporary relation.  *Tutorial D*
has syntax for doing this, but up to this point dinsd hasn't, though we
could have used it in a few examples up above.

So, the dinsd way of dynamically creating a relation definition and a single
instance of that definition at the same time is ``Rel``:

    >>> from dinsd.op import Rel
    >>> print(Rel(name=str, sid=SID)(('name', 'sid'), ('Boris', 'S1')))
    +-------+-----+
    | name  | sid |
    +-------+-----+
    | Boris | S1  |
    +-------+-----+

``Rel`` is essentially the ``lambda`` of relations:

    >>> namelist = Rel(name=str)
    >>> print(namelist(('name',), ('Boris',), ('Anne',)))
    +-------+
    | name  |
    +-------+
    | Anne  |
    | Boris |
    +-------+
    >>> print(namelist(('name',), ('Anne',), ('George',)))
    +--------+
    | name   |
    +--------+
    | Anne   |
    | George |
    +--------+

Now we can complete the "existing operators" version of the restriction
query at the start of 4.7:

    >>> print((is_called & Rel(name=str)(dict(name='Boris')))
    ...              >> {'student_id'})
    +------------+
    | student_id |
    +------------+
    | S2         |
    | S5         |
    +------------+


where
-----

I'm not convinced that ``where`` is actually a part of the relational
algebra, but there is no denying its usefulness.

    >>> from dinsd.op import where

Example 4.7 on page 105 looks like this:

    >>> print(where(is_called, lambda row: row.name == 'Boris'))
    +-------+------------+
    | name  | student_id |
    +-------+------------+
    | Boris | S2         |
    | Boris | S5         |
    +-------+------------+

It would be nice if there were some shorter shorthand than ``lambda`` for
providing the expression, but in Python there isn't.

Here is example 4.8 written in dinsd:

    >>> print(where(is_called, lambda row: row.name.startswith('B')))
    +-------+------------+
    | name  | student_id |
    +-------+------------+
    | Boris | S2         |
    | Boris | S5         |
    +-------+------------+

With Python, it is easy to make this a bit more interesting:

    >>> print(where(is_called, lambda row: row.name.startswith(('B', 'A'))))
    +-------+------------+
    | name  | student_id |
    +-------+------------+
    | Anne  | S1         |
    | Boris | S2         |
    | Boris | S5         |
    +-------+------------+

Here are the edge cases from the bottom of page 106:

    >>> where(is_called, lambda row: True) == is_called
    True
    >>> where(is_called, lambda row: False) == type(is_called)()
    True

And now we can further improve the problem of finding just those student_ids
that designate students with the same name (figure 4.8 on page 107):

    >>> x = join(rename(is_called, student_id='sid1'),
    ...          rename(is_called, student_id='sid2')) >> {'sid1', 'sid2'}
    >>> print(where(x, lambda row: row.sid1 != row.sid2))
    +------+------+
    | sid1 | sid2 |
    +------+------+
    | S2   | S5   |
    | S5   | S2   |
    +------+------+

And of course the final version has the obvious analog in dinsd:

    >>> print(where(x, lambda row: row.sid1 < row.sid2))
    +------+------+
    | sid1 | sid2 |
    +------+------+
    | S2   | S5   |
    +------+------+

I will observe here that I didn't just use the ``x`` intermediate variable to
provide for less repetition in the examples, but also because I prefer that
"coding" style.  Rather than a single grand expression, it seems clearer to me
to break a computation up into pieces, somewhat in the way a mathematical
paper will often say, "let x = <something>, then <expression involving x>".


extend
------

This operator allows us to create a new relation that extends an existing
relation by performing a computation on the attributes of the initial
relation.

    >>> from dinsd.op import extend

Here is the expression that results in the example in figure 4.10 on pages
109 and 109:

    >>> x = extend(is_called, initial=lambda row: row.name[0])
    >>> print(display(x, 'student_id', 'name', 'initial'))
    +------------+----------+---------+
    | student_id | name     | initial |
    +------------+----------+---------+
    | S1         | Anne     | A       |
    | S2         | Boris    | B       |
    | S3         | Cindy    | C       |
    | S4         | Devinder | D       |
    | S5         | Boris    | B       |
    +------------+----------+---------+

A null extension is an identity operation:

    >>> extend(is_called) == is_called
    True

Unlike *Tutorial D*, we do not have a left to right evaluation order for
extension expressions, so extension expressions in dinsd may only refer to
attributes from the base relation, not any newly created attributes.  This is
a minor restriction, since it is simple enough (and often clearer) to write
multiple extension expressions in order in such a case.  It would also be
possible to relax this restriction by using (name, func) tuples or some
inspect trickery and doing the extension one attribute at a time, but this
hardly seems worth the effort for what is probably an infrequent use case.


union
~~~~~

In the relational algebra, ``union`` corresponds to the ``or`` logical
operator, but is restricted to being an operator on relations whose
types are equal.  dinsd, like *Tutorial D*, provides ``union`` both
as a function and as an operator.  In dinsd the operator is ``|``.

    >>> from dinsd.op import union

We compute example 4.9 on page 111 thusly:

    >>> x = where(is_called, lambda row: row.name == 'Devinder')
    >>> y = where(is_enrolled_on, lambda row: row.course_id == CID('C1'))
    >>> ex49 = x >> {'student_id'} | y >> {'student_id'}
    >>> ex49 == union(x >> {'student_id'}, y >> {'student_id'})
    True
    >>> print(ex49)
    +------------+
    | student_id |
    +------------+
    | S1         |
    | S2         |
    | S4         |
    +------------+

It is an error to try to form the union of relations of disparate types:

    >>> is_called | is_enrolled_on
    Traceback (most recent call last):
        ...
    TypeError: Union operands must of equal types

Union is commutative and associative:

    >>> x = x >> {'student_id'}
    >>> y = y >> {'student_id'}
    >>> x | y == y | x
    True
    >>> z = Rel(student_id=SID)({'student_id': 'S5'})
    >>> (x | y) | z == x | (y | z) == union(x, y, z)
    True

Union of a single relation, or a relation with itself, is that relation.

    >>> union(is_called) == union(is_called, is_called) == is_called
    True

*Tutorial D* has the ability to return an empty union if you specify
a heading.  The equivalent in dinsd is the following, which, like
the *Tutorial D* version, is of questionable practical value but
provided just in case:

    >>> union() == Dum
    True
    >>> print(union(Rel(name=str, student_id=SID)))
    +------+------------+
    | name | student_id |
    +------+------------+
    +------+------------+

Of course, the union of an empty relation returns an equivalent empty
relation, and that is probably more useful.

Be warned that passing a type in any other context to a relational operator
will result in oddball errors in dinsd, rather than straightforward TypeErrors
with useful messages.  This may be improved at some point, or it may not.


notmatching
~~~~~~~~~~~

Although the name is a bit more awkward in dinsd than it is in *Tutorial D*,
we approximately follow the *Tutorial D* naming for this function.  Since
it is the more general of the two difference functions (``minus`` and
``notmatching``), we also provide it as the operator ``-``.

    >>> from dinsd.op import notmatching

Here is example 4.11 from page 115:

    >>> not_enrolled = notmatching(is_called, is_enrolled_on)
    >>> not_enrolled == is_called - is_enrolled_on
    True
    >>> print(not_enrolled)
    +-------+------------+
    | name  | student_id |
    +-------+------------+
    | Boris | S5         |
    +-------+------------+

Since we are using the '-' operator and the operation is also referred to as a
"semidiffernce", we will use the imprecise but convenient terminology
"subtract" for this operation.

If we subtract from an empty relation we get an empty relation.  On the other
hand, if we subtract an empty relation we get the original relation (we
subtract nothing).

    >>> type(is_called)() - is_enrolled_on == type(is_called)()
    True
    >>> is_called - type(is_enrolled_on)() == is_called
    True

If we subtract a relation that has no common attributes, then if that
relation is empty (no matching rows) we get back the original relation.
If, however, it is not empty, then by the relational rules *all* the
rows match, and we get back the empty relation.

    >>> is_called - Rel(foo=str)() == is_called
    True
    >>> is_called - Rel(foo=str)(dict(foo='bar')) == type(is_called)()
    True

It is an error for match columns with the same name to have different types.

    >>> is_called - Rel(student_id=str)()  # doctest: +NORMALIZE_WHITESPACE
    Traceback (most recent call last):
        ...
    TypeError: Duplicate attribute name ('student_id') with different type
        (first: <class '__main__.SID'>, second: <class 'str'> found in
         match relation (relation type names are <class '__main__.IsCalled'>
         and <class 'dinsd.dbdef.rel_student_id'>)

minus
~~~~~

The ``minus`` operator is a subset of ``notmatching``, where the two
relations must have exactly the same columns, meaning that only exact
matches are removed.

    >>> from dinsd.op import minus
    >>> anne = Rel(student_id=SID, name=str)(dict(student_id='S1', name='Anne'))
    >>> print(minus(is_called, anne))
    +----------+------------+
    | name     | student_id |
    +----------+------------+
    | Boris    | S2         |
    | Boris    | S5         |
    | Cindy    | S3         |
    | Devinder | S4         |
    +----------+------------+
    >>> minus(is_called, Rel(student_id=SID)())
    Traceback (most recent call last):
        ...
    TypeError: Relation types must match for minus operation


Chapter 4 Exercises
~~~~~~~~~~~~~~~~~~~

Just for fun (well, and to improve our test coverage), we'll do some of the
exercises from the end of chapter 4 in AITDT.  There won't be much if any
explanation here, just code.

Note that we still aren't dealing with keys or other constraints yet.

Exercise 2:

    >>> from datetime import date
    >>> class date_type(date):
    ...     def __new__(cls, value):
    ...         if isinstance(value, date):
    ...             return value
    ...         return super().__new__(cls, *value)
    >>> class Cust(dbdef.Relation):
    ...     c_no = str
    ...     discount = float
    >>> class Orders(dbdef.Relation):
    ...     o_no = str
    ...     c_no = str
    ...     date = date_type
    >>> class OrderItem(dbdef.Relation):
    ...     o_no = str
    ...     p_no = str
    ...     qty = int
    >>> class Product(dbdef.Relation):
    ...     p_no = str
    ...     unit_price = float
    >>> cust = Cust(
    ...         ('c_no', 'discount'),
    ...         ('0012', 10.0),
    ...         ('1001', 5.0),
    ...         ('5', 20.0),
    ...         )
    >>> orders = Orders(
    ...         ('o_no', 'c_no', 'date'),
    ...         ('0001', '0012', date(2012, 11, 4)),
    ...         ('0002', '0012', (2012, 11, 5)),
    ...         ('0003', '5', date(2012, 11, 3)),
    ...         )
    >>> order_items = OrderItem(
    ...         ('o_no', 'p_no', 'qty'),
    ...         ('0001', '20001', 2),
    ...         ('0001', '20002', 3),
    ...         ('0002', '20001', 7),
    ...         ('0003', '2201', 20),
    ...         )
    >>> products = Product(
    ...         ('p_no', 'unit_price'),
    ...         ('20001', 120.50),
    ...         ('20002', 12.75),
    ...         ('2201', 1000.00),
    ...         )
    >>> x = order_items & products & orders & cust
    >>> x = extend(x, price=lambda row: (
    ...         round(row.qty*row.unit_price*(1-row.discount/100), 2)))
    >>> x = x >> {'o_no', 'p_no', 'price'}
    >>> print(display(x, 'o_no', 'p_no', 'price'))
    +------+-------+---------+
    | o_no | p_no  | price   |
    +------+-------+---------+
    | 0001 | 20001 | 216.9   |
    | 0001 | 20002 | 34.43   |
    | 0002 | 20001 | 759.15  |
    | 0003 | 2201  | 16000.0 |
    +------+-------+---------+

Exercise 3:

    >>> class ExamMark(dbdef.Relation):
    ...     student_id = SID
    ...     course_id = CID
    ...     mark = int
    >>> exam_marks = ExamMark(
    ...     ('student_id', 'course_id', 'mark'),
    ...     ('S1',         'C1',        85),
    ...     ('S1',         'C2',        49),
    ...     ('S1',         'C3',        85),
    ...     ('S2',         'C1',        49),
    ...     ('S3',         'C3',        66),
    ...     ('S4',         'C1',        93),
    ...     )
    >>> x = rename(exam_marks, student_id='sid1', mark='mark1')
    >>> y = rename(exam_marks, student_id='sid2', mark='mark2')
    >>> pairs = where(x & y, lambda r: r.sid1 < r.sid2)
    >>> diff = extend(pairs, gap=lambda r: abs(r.mark1 - r.mark2))
    >>> diff_only = diff << {'mark1', 'mark2'}
    >>> print(display(diff_only, 'course_id', 'sid1', 'sid2', 'gap'))
    +-----------+------+------+-----+
    | course_id | sid1 | sid2 | gap |
    +-----------+------+------+-----+
    | C1        | S1   | S2   | 36  |
    | C1        | S1   | S4   | 8   |
    | C1        | S2   | S4   | 44  |
    | C3        | S1   | S3   | 19  |
    +-----------+------+------+-----+

Because it is obviously going to be convenient, I've decided to allow
``display`` to do an implicit projection if the number of columns
specified is less than the number of columns in the relation being
displayed:

    >>> print(display(diff, 'course_id', 'sid1', 'sid2', 'gap'))
    +-----------+------+------+-----+
    | course_id | sid1 | sid2 | gap |
    +-----------+------+------+-----+
    | C1        | S1   | S2   | 36  |
    | C1        | S1   | S4   | 8   |
    | C1        | S2   | S4   | 44  |
    | C3        | S1   | S3   | 19  |
    +-----------+------+------+-----+

This means we now get a different error when we specify an invalid
attribute name:

    >>> display(diff, 'fred')
    Traceback (most recent call last):
        ...
    AttributeError: '_rowclass_' object has no attribute 'fred'

That is clear enough that there's no reason to specialize it.

This also implies that display without a column list is equivalent
to an invalid version of Dee:

    >>> print(display(diff))
    ++
    ||
    ++
    |  |
    |  |
    |  |
    |  |
    ++

For now at least we are just going to live with that artifact, because
display is not a relational operator, since it does not return a
relation.

Exercise 4:

    >>> is_called - Dee
    IsCalled(('name', 'student_id'))
    >>> is_called - Dum == is_called
    True
    >>> is_called - is_called
    IsCalled(('name', 'student_id'))
    >>> (is_called - is_called) - is_called
    IsCalled(('name', 'student_id'))
    >>> is_called - (is_called - is_called) == is_called
    True

``notmatching`` is neither commutative nor associative, which makes
using the ``-`` operator for it a bit dicey...but so very convenient.

Oh, and for completeness: ``rename`` can be written in terms of
``extend``:

    >>> x = rename(is_called, student_id='sid')
    >>> y = extend(is_called, sid=lambda r: r.student_id) << {'student_id'}
    >>> x == y
    True


mtching
~~~~~~~

Following along in Chapter 5, for completeness.  We already defined the
exam_marks relation instance in one of the problems above.  Now we'll
add courses.

    >>> class Course(dbdef.Relation):
    ...     course_id = CID
    ...     title = str
    >>> courses = Course(
    ...             ('course_id',   'title'),
    ...             ('C1',          'Database'),
    ...             ('C2',          'HCI'),
    ...             ('C3',          'Op systems'),
    ...             ('C4',          'Programming'),
    ...             )
    >>> print(courses)
    +-----------+-------------+
    | course_id | title       |
    +-----------+-------------+
    | C1        | Database    |
    | C2        | HCI         |
    | C3        | Op systems  |
    | C4        | Programming |
    +-----------+-------------+
    >>> print(display(exam_marks, 'student_id', 'course_id', 'mark'))
    +------------+-----------+------+
    | student_id | course_id | mark |
    +------------+-----------+------+
    | S1         | C1        | 85   |
    | S1         | C2        | 49   |
    | S1         | C3        | 85   |
    | S2         | C1        | 49   |
    | S3         | C3        | 66   |
    | S4         | C1        | 93   |
    +------------+-----------+------+

*Tutorial D*'s expression:

   ``( COURSE JOIN EXAM_MARK ) { ALL BUT StudentId, Mark }``

becomes the dinsd expression:

    >>> print((courses & exam_marks) << {'student_id', 'mark'})
    +-----------+------------+
    | course_id | title      |
    +-----------+------------+
    | C1        | Database   |
    | C2        | HCI        |
    | C3        | Op systems |
    +-----------+------------+

The ``matching`` relational operator encapsulates this (union plus
projecting away any columns obtained from the second relation):

    >>> from dinsd.op import matching
    >>> print(matching(courses, exam_marks))
    +-----------+------------+
    | course_id | title      |
    +-----------+------------+
    | C1        | Database   |
    | C2        | HCI        |
    | C3        | Op systems |
    +-----------+------------+

Although this is the opposite of ``notmatching`` in a relational sense,
it is not an intuitive match for ``+`` the way ``notmatching`` is for
``-``.  Hence we do not overload any Python operators for this relational
operator.

A match against an empty relation is empty:

    >>> matching(type(courses)(), courses)
    Course(('course_id', 'title'))

In the reverse of the case for ``notmatching``, if there are no common
attributes matching against an empty relation produces an empty relation,
while matching against a non-empty relation produces the original
relation:

    >>> matching(courses, Dum)
    Course(('course_id', 'title'))
    >>> matching(courses, Dee) == courses
    True

compose
~~~~~~~

    >>> from dinsd.op import compose
    >>> course_marks = compose(courses, exam_marks)
    >>> course_marks == (courses & exam_marks) << {'course_id'}
    True
    >>> print(display(course_marks, 'title', 'student_id', 'mark',
    ...                             sort=('student_id', 'title')))
    +------------+------------+------+
    | title      | student_id | mark |
    +------------+------------+------+
    | Database   | S1         | 85   |
    | HCI        | S1         | 49   |
    | Op systems | S1         | 85   |
    | Database   | S2         | 49   |
    | Op systems | S3         | 66   |
    | Database   | S4         | 93   |
    +------------+------------+------+

If there are no common attributes, ``compose`` is the same as ``join``:

    >>> r1 = Rel(foo=int, bar=int)(('foo', 'bar'), (1, 2), (3, 4))
    >>> r2 = Rel(bing=int, bang=int)(('bing', 'bang'), (5, 6), (7, 8))
    >>> join(r1, r2) == compose(r1, r2)
    True

Compose is commutative, but not associative:

    >>> compose(courses, exam_marks) == compose(exam_marks, courses)
    True
    >>> r = Rel(student_id=SID, marks=int, name=str)(
    ...             ('student_id', 'marks', 'name'),
    ...             ('S1',         30,      'Anne'),
    ...             ('S2',         20,      'Borris'))
    >>> c1 = compose(compose(is_called, r), exam_marks)
    >>> c2 = compose(is_called, compose(r, exam_marks))
    >>> c1 == c2
    False


Aggregate Operators
-------------------

Aggregate operators map from relations to scalers.


len (count)
~~~~~~~~~~~

*Tutorial D* calls this operator ``COUNT``, but Python already has a
perfectly good function for returning the number of rows in a
relation: ``len``:

    >>> len(is_called)
    5
    >>> len(exam_marks)
    6

That was example 5.1 on page 127.  Example 5.2, counting the number of
students with marks above 50:

    >>> len(where(exam_marks, lambda r: r.mark > 50) >> {'student_id'})
    3



About the Name
--------------

When I started dinsd, I knew there was no way I could fully implement
TTM's *D* in Python.  But I wanted something very like *D*.  Given that I was
implementing *D* in Python, I figured I should use the name of some character
that had something to do with the letter D, and Dinsdale immediately came to
mind.  However, since my program was not going to be a full D, I decided I'd
shorten the name to indicate it was only a partial thing.  This also served to
make it a more uniquely searchable term.  I contemplated both 'dins' and
'dinsd', settling on the latter because it had two Ds in it.

After a bit I realized that I was developing something closer to the true
spirit of *D* than I had initially thought I'd be able to manage, but still
something that did not conform to TTM.  It occurred to me that 'dinsd' could
almost, but not quite, be interpreted as "D Is Not D", and I briefly
considered changing the name to disnd.  That's a lot harder to pronounce,
though.

And then it occured to me that the big difference between my (non-conformant)
implementation of *D* and a real *D* is that Python does not have compile
time, static typing.  And thus the real acronym behind the name dinsd was
revealed:

    D Is Not Static D

It isn't really quite *D* in a few other details as well, but that's the big
one.
