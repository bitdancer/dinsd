Disnd and An Introduction to Relational Database Theory
=======================================================


Introduction
------------

Dinsd was initially developed while I went through the book

    An Introduction to Relational Database Theory
    by Hugh Darwen

This book uses his and C. J. Date's notional ``D`` implementation, *Tutorial
D*, and gives various examples and problems based on *Tutorial D* to elucidate
the concepts of Relational Algebra.  ``D`` and *Tutorial D* are in turn
defined fully in Hugh and C. J.'s seminal work

    The Third Manifesto

This file writes out various examples in dinsd that correspond to examples
and/or problems from the book, as well as other examples that were inspired by
the book or explored during the writing of dinsd.  The examples here do not
particularly follow the book, as writing the implementation required hoping
around a bit in the conceptual space, but the general pattern does follow
the book.

Where reference is made to specific page numbers or figures in AIRTD, this is
based on the bookboon.com edition of the book as available for download on
November 1st, 2012.

This file contains blocks of tests that are meant to exercise edge cases as
well as the primary test cases and examples, because it is the test document
that I used as I was building the system.  It is, therefore, a cross between a
design document, a literate test document, and a detailed discussion of the
system mechanics.  It may not be the best possible introduction to dinsd, but
if you can make your way through it you will have a fairly deep understanding
of dinsd and its relationship to TTM and its correspondence (or lack thereof)
to *Tutorial D*.


Scalars, Rows, and Relations (and a Few Words About Databases)
--------------------------------------------------------------

Databases and Terminology
~~~~~~~~~~~~~~~~~~~~~~~~~

The concept of a database holding a set of relations is central to *Tutorial
D*, but the process for defining a database is only introduced implicitly.  We
will do the same, talking about the conceptual framework of the database,
but defer the discussion of the syntax for defining one until later.

A database in dinsd consists of a container for the database, and a name and
definition for all of the relations that are stored in the container.  This is
what is usually called a "schema" in SQL.  Dinsd refers to it as a "DBDef"
(Database Definition).  Unlike a traditional SQL DBMS, dinsd does not store
the ``DBDef`` "in the catalog"; instead the Python program holds the
``DBDef``, and only the data is stored in the persistent store.  This means
that dnsd is not by itself a DBMS...in order to have a dinsd based DBMS, you
would need to write an application that would manage ``DBDef`` definitions as
data objects, and persist them.  While this is conceptually possible, it is
not something I need for the first intended application of dinsd and so is not
addressed here.

The facilities for defining databases and relations are provided by the dinsd
module ``dbdef``.

    >>> from dinsd import dbdef

A database is a set of relations.  Per TTM and AIRDT, a relation consists of a
header plus a set of ``tuples`` that conform to that header.  Since Python
already uses the term ``tuple`` to refer to a different concept, we will fall
back to the less precise but more widely recognized term ``row``.  I'm sure
the authors of TTM would/will be annoyed by this, but it is less confusing
than trying to reuse the world ``tuple`` in a Python context.

So, a relation consists of a name and a header.  The header consists of a list
of attributes, with each attribute having a type.


Types, User Defined Types, and Scalars
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Python is strictly typed.  Defining new types in Python is very simple:  you
define a class.  (Classes are, in fact, of type ``type`` in Python).  So, to
define the type for an attribute, we need a class that is that type.  For
standard types (``int``, ``str``, etc), we can use the Python built in types.
For what TTM calls "user defined types", we define a new class.

In order to maintain consistency, every user defined scaler type (ie:
non-relation type) used with dinsd must conform to the common syntax and
semantics of the Python built in types:  the type constructor at a minimum
accepts one argument, and either raises an error if the argument (the
"selector" in TTM/AIRDT terms) cannot be converted into a valid instance of
the type, or a valid instance of the type if it can be.  In Python terms, this
means that the class's ``__init__`` method must accept at least one positional
argument.  (For the purposes of dinsd, this argument should always be present,
even if it is optional in the class definition for other reasons.)

It is also critical that, like the Python built in types, the user defined
type accept an instance of itself as a valid selector, and return an
equivalent instance.  (Note that this requirement is not true for *Tutorial
D*.  We'll discuss why it is true for dinsd below.)

In addition to the conformance checking in the ``__init__`` method, there are
some auxiliary methods that every user defined scaler type must have.
Therefore dinsd provides a base type for such user defines scalers, named
``Scaler``.  A simple ``Scaler`` type must always store its value in an attribute
named ``value``.

There is nothing preventing an application from defining a type without using
``Scaler`` as the superclass, or using ``Scaler`` and implementing a more
complex value store, but if an application does so it is responsible for
correctly implementing the equivalents of all of the methods that ``Scaler``
provides.  Specifically, it must provide all the methods to define a total
ordering of the values, as required by TTM.

So, we can now define the ``SID`` and ``CID`` types that are introduced in
chapter 2 of AIRDT:

    >>> class ID(dbdef.Scaler):
    ...
    ...     def __init__(self, id):
    ...         if isinstance(id, self.__class__):
    ...             self.value = id.value
    ...             return
    ...         if not isinstance(id, str):
    ...             raise TypeError(
    ...                 "Expected str but passed {}".format(type(id)))
    ...         if (2 <= len(id) <=4 and id.startswith(self.firstchar) and
    ...                 id[1:].isdigit()):
    ...             self.value = id
    ...         else:
    ...             raise TypeError(
    ...                 "Expected '{}' followed by one to three digits; {!r} "
    ...                 "is invalid".format(self.firstchar, id))
    ...
    >>> class SID(ID):
    ...     firstchar = 'S'
    ...
    >>> class CID(ID):
    ...     firstchar = 'C'

This definition corresponds to example 2.4 on page 47 of AIRDT.  It looks
somewhat more complicated, but this is primarily because defining the error
messages resulting from "selection" failure, whereas example 2.4 is leaving
those error messages to be automatically generated by the *Tutorial D* system.

Semantically the examples are equivalent.  We are using Python built
in functions for the checks, whereas in *Tutorial D* the check functions are
user defined (and their definition is deferred to later in the book).
The *Tutorial D* ``C CHAR`` declaration corresponds to our ``self.value =
id``, with the difference that our self.value is not typed.  The *value* has a
type, which our code is constraining to be ``str`` (Python's equivalent
of *Tutorial D*'s ``CHAR``), but as is normal in Python the name we store it
under is not itself typed.

To prove that this (straightforward Python) implementation is correct:

    >>> SID('S1')
    SID('S1')
    >>> CID('C1')
    CID('C1')
    >>> SID(SID('S1'))
    SID('S1')
    >>> print(SID('S2'))
    S2
    >>> SID('1')
    Traceback (most recent call last):
        ...
    TypeError: Expected 'S' followed by one to three digits; '1' is invalid
    >>> CID(1)
    Traceback (most recent call last):
        ...
    TypeError: Expected str but passed <class 'int'>
    >>> SID('C1')
    Traceback (most recent call last):
        ...
    TypeError: Expected 'S' followed by one to three digits; 'C1' is invalid
    >>> CID('C0003')
    Traceback (most recent call last):
        ...
    TypeError: Expected 'C' followed by one to three digits; 'C0003' is invalid
    >>> SID(CID('C1'))
    Traceback (most recent call last):
        ...
    TypeError: Expected str but passed <class '__main__.CID'>
    >>> SID('S1') == SID('S1')
    True
    >>> SID('S1') != CID('C1')
    True
    >>> SID('S2') == SID(SID('S2'))
    True
    >>> SID('S1') < SID('S2')
    True
    >>> CID('C7') >= CID('C7')
    True
    >>> SID('S1') > CID('C2')
    Traceback (most recent call last):
        ...
    TypeError: unorderable types: SID() > CID()


Defining and Instantiating Relations
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

A relation in dinsd is also a class, which is nice because in TTM it is also a
type, making this consistent between TTM and dinsd/Python.  As mentioned
above, for a relation, the class (type) definition consists of a list of
attributes and their types.

We will demonstrate this by defining the example relation used throughout the
first couple chapters of AIRDT.  This corresponds to the  *Tutorial D* type
definition that is given on page 42 of AIRDT.

    >>> class IsEnrolledOn(dbdef.Relation):
    ...     student_id = SID
    ...     name = str
    ...     course_id = CID

Because relations share a common semantic, we don't need to define an explicit
``__init__`` function.  All ``Relation`` types automatically have an
``__init__`` method that allows us to construct a relation (relvar) of that
type by providing data to extend the relation.

The most verbose and most general way of creating such a relation instance is
as follows:

    >>> is_enrolled_on = IsEnrolledOn(
    ...     IsEnrolledOn._row_({'student_id': SID('S1'), 'course_id': CID('C1'), 'name': 'Anne'}),
    ...     IsEnrolledOn._row_({'student_id': SID('S1'), 'course_id': CID('C2'), 'name': 'Anne'}),
    ...     IsEnrolledOn._row_({'student_id': SID('S2'), 'course_id': CID('C1'), 'name': 'Boris'}),
    ...     IsEnrolledOn._row_({'student_id': SID('S3'), 'course_id': CID('C3'), 'name': 'Cindy'}),
    ...     IsEnrolledOn._row_({'student_id': SID('S4'), 'course_id': CID('C1'), 'name': 'Devinder'}),
    ...     )

This corresponds directly to the relation definition in example 2.3 on page
45.  As I indicated earlier, we are using the term ``row`` instead of the term
``tuple`` to avoid confusion with the Python ``tuple`` type.

You may wonder about the odd (at least to Python eyes) method name '_row_'.  A
relation must be able to hold attributes with any "normal" name...we do not
want there to be an "reserved" identifiers the way there are in some SQL
dialects.  So any valid Python identifier is a valid attribute name...except
ones that start with '_'.  We can thus use names that start with '_' as the
names of non-relation-attribute attributes of the Python class.  However, the
normal Python convention is that names that start with a single '_' are
"private" names, and not part of the API.  In order to distinguish dinsd
method names that *are* part of the API, we also suffix the name with a '_'.
Thus, attribute identifiers in dinsd that both start and end with a '_'
are *methods* that are part of the public API.

If you compare the above "relation literal" with the one from example 2.3 in
AIRDT, you might notice a major difference between disnd and *Tutorial D*, one
of the ones that makes dinsd not technically compatible with TTM.  In TTM
(and *Tutorial D*) a type is completely characterized by the names of the
attributes and the types of the values.  If two definitions or two literals
refer to the *same* set of names, with the value associated with each name
having the *same* type, then the two are considered to be *exactly* the same
type for all purposes.  Python, on the other hand, bases type identity on the
identity of the *object* that defines the type.  Thus in our version of the
Relation literal above, we must explicitly name the type that we are
instantiating, so that Python can follow the pointer to the single type object
that defines this Relation type.  While this technically violates TTM, in
practice we allow relvars that have conformant types in the TTM sense to fully
interoperate.  Thus in practice the difference has a consequence only in the
way in which Relations and Tuples are created, and not on the way in which
they are used.

You will also note that dinsd does not provide any direct syntax for defining
a row independent of any Relation, unlike *Tutorial D*, which provides the
TUPLE keyword for both type and literal definition.  In disd a row selector
function is accessible only from the corresponding `Relation` type that uses
the same header.  This also does not fully conform to TTM, but I haven't
found a need to define a row without also defining the corresponding Relation,
so I don't think it is a significant omission.

The instantiation above is *very* wordy.  Given that in dinsd we know which
type of relation we are instantiating, we can provide usefully simpler
representations.

First, we know that the body of the relation is a list of rows, so there is no
need to pass in explicitly constructed rows.  Instead, if the init method is
passed a simple Python dictionary, it can do the conversion-to-row itself:

    >>> is_enrolled_on2 = IsEnrolledOn(
    ...     {'student_id': SID('S1'), 'course_id': CID('C1'), 'name': 'Anne'},
    ...     {'student_id': SID('S1'), 'course_id': CID('C2'), 'name': 'Anne'},
    ...     {'student_id': SID('S2'), 'course_id': CID('C1'), 'name': 'Boris'},
    ...     {'student_id': SID('S3'), 'course_id': CID('C3'), 'name': 'Cindy'},
    ...     {'student_id': SID('S4'), 'course_id': CID('C1'), 'name': 'Devinder'},
    ...     )

Second, by relaxing from the purity of never using ordered tuples we can
significantly reduce the typing required to enter a relation literal:

    >>> is_enrolled_on3 = IsEnrolledOn(
    ...     ('student_id', 'course_id', 'name'),
    ...     (SID('S1'), CID('C1'), 'Anne'),
    ...     (SID('S1'), CID('C2'), 'Anne'),
    ...     (SID('S2'), CID('C1'), 'Boris'),
    ...     (SID('S3'), CID('C3'), 'Cindy'),
    ...     (SID('S4'), CID('C1'), 'Devinder'),
    ...     )

Here the ``__init__`` method sees that it is being passed (Python) tuples
instead of dictionaries, and takes the first such tuple as the ordered list
of attributes and each subsequent tuple as a correspondingly ordered list
of attribute values.

Finally, by taking advantage of the fact that we know the type of the
attributes and have access to the selector function for that type, we can
produce a minimally simple representation by not requiring the type of the
attribute value to explicitly specified in the literal:

    >>> is_enrolled_on4 = IsEnrolledOn(
    ...     ('student_id', 'course_id', 'name'),
    ...     ('S1', 'C1', 'Anne'),
    ...     ('S1', 'C2', 'Anne'),
    ...     ('S2', 'C1', 'Boris'),
    ...     ('S3', 'C3', 'Cindy'),
    ...     ('S4', 'C1', 'Devinder'),
    ...     )

There is no loss of type-safety here, since each selector is passed through
the type constructor, which will raise an error if the argument value does
not conform to the selector.

You can see now why it is critical that the type constructor accept an
instance of itself as valid:  the relation constructor will always pass the
value of an attribute through the corresponding type function for validation,
and an instance of that type must be reported as valid.

It might appear as though there is another step of simplification we could do:
not require the first tuple of attribute names, but instead assume the same
ordering as that used in the relation definition.  Although it would
technically be possible to do this in Python (by using an ``OrderedDict`` for
the Relation class dictionary) it is not a natural fit for normal Python
semantics, and would (unlike, I believe, the previous simplifications)
definitely violate the spirit of TTM by making the meaning of a relation
literal dependent on the order of definition of the attributes in the relation
definition.  In contrast, the final simplification above is not dependent on
the definition order, only on the types, which cannot change.

So, in dinsd you can choose the level of correspondence to the *Tutorial D*
literal notation that you prefer.  All of the above representations produce
the same relvar value:

    >>> is_enrolled_on == is_enrolled_on2 == is_enrolled_on3 == is_enrolled_on4
    True

It's ``repr`` is one of the more compact version of the literal representation:

    >>> is_enrolled_on     # doctest: +NORMALIZE_WHITESPACE
    IsEnrolledOn(('course_id', 'name',    'student_id'),
                   (CID('C1'), 'Anne',     SID('S1')),
                   (CID('C1'), 'Boris',    SID('S2')),
                   (CID('C1'), 'Devinder', SID('S4')),
                   (CID('C2'), 'Anne',     SID('S1')),
                   (CID('C3'), 'Cindy',    SID('S3')))

Of course, the real repr is a single line and so is not as pretty as the
example makes it look.  We've lined up the example so that you can notice that
the attributes are sorted alphabetically, and the rows are sorted according to
their values as tuples.  We could also just allow them to be in their
"natural" order, but in Python that is semi-random and it is more convenient
to have a consistent ordering in the representation.

The ``str`` (printed) representation is likewise sorted, but is in a more
convenient format for inspecting the relation:

    >>> print(is_enrolled_on)
    +-----------+----------+------------+
    | course_id | name     | student_id |
    +-----------+----------+------------+
    | C1        | Anne     | S1         |
    | C1        | Boris    | S2         |
    | C1        | Devinder | S4         |
    | C2        | Anne     | S1         |
    | C3        | Cindy    | S3         |
    +-----------+----------+------------+

Testing the Edges
~~~~~~~~~~~~~~~~~

So much for the basics and the simple initial example from AIRDT Chapter 2.
Let's take a look at some edge cases to make sure the code handles them.

First of all, we can create an empty Relation:

    >>> is_enrolled_on = IsEnrolledOn()
    >>> is_enrolled_on
    IsEnrolledOn(('course_id', 'name', 'student_id')
    >>> print(is_enrolled_on)
    +-----------+------+------------+
    | course_id | name | student_id |
    +-----------+------+------------+
    +-----------+------+------------+

The dictionary passed to the _row_ constructor must have the right number of
values:

    >>> IsEnrolledOn._row_({})
    Traceback (most recent call last):
        ...
    TypeError: Expected 3 attributes, got 0
    >>> IsEnrolledOn._row_({'student_id': 'S1', 'name': 'foo'})
    Traceback (most recent call last):
        ...
    TypeError: Expected 3 attributes, got 2
    >>> IsEnrolledOn._row_({'student_id': 'S1', 'name': 'foo',
    ...                         'course_id': 'C1', 'bar': 1})
    Traceback (most recent call last):
        ...
    TypeError: Expected 3 attributes, got 4

And the attribute names must match those defined in the relation:

    >>> IsEnrolledOn._row_({'student_id': 'S1', 'name': 'foo', 'bad': 1})
    Traceback (most recent call last):
        ...
    TypeError: Invalid attribute name bad

The values must be valid:

    >>> IsEnrolledOn._row_({'student_id': 'S1', 'name': 'foo', 'course_id': 1})
    Traceback (most recent call last):
        ...
    TypeError: Expected str but passed <class 'int'>
    >>> IsEnrolledOn._row_({'student_id': 'S1', 'name': 'foo', 'course_id': 'S1'})
    Traceback (most recent call last):
        ...
    TypeError: Expected 'C' followed by one to three digits; 'S1' is invalid

But it is OK to use the selector form ('C1') rather than the full scaler
value form (CID('C1')):

    >>> r = IsEnrolledOn._row_(
    ...         {'student_id': 'S1', 'name': 'foo', 'course_id': 'C1'})

A row also has a distinct ``repr`` and ``str``:

    >>> r                       # doctest: +NORMALIZE_WHITESPACE
    IsEnrolledOn._row_({'course_id': CID('C1'), 'name': 'foo', 'student_id':
                        SID('S1')})
    >>> print(r)
    (course_id=C1, name=foo, student_id=S1)

You will note that as with the ``repr``  and ``str`` of a ``Relation``, the
``repr`` and ``str`` of a ``row`` is sorted by the attribute names.  The
``str`` representation of a ``row`` is not nearly as useful as that of
a ``Relation``, but is provided for completeness.

The same type checking happens when instantiating a Relation using the
shorthand, and additionally reports which row is in error:

    >>> IsEnrolledOn(('course_id', 'name'),
    ...               ('S1', 'Anne'))
    Traceback (most recent call last):
        ...
    TypeError: Expected 3 attributes, got 2 in header row
    >>> IsEnrolledOn(('course_id', 'name', 'student_id'),
    ...               ('C1', 'Anne'))
    Traceback (most recent call last):
        ...
    TypeError: Expected 3 attributes, got 2 in row 1
    >>> IsEnrolledOn(('course_id', 'name', 'student_id'),
    ...               ('C1', 'Anne', 'S1'),
    ...               ('C2', 'Anne', 'S1', 'foo'),
    ...               )
    Traceback (most recent call last):
        ...
    TypeError: Expected 3 attributes, got 4 in row 2
    >>> IsEnrolledOn(('course_id', 'name', 'foo'),
    ...               ('C1', 'Anne', 'S1'),
    ...               )
    Traceback (most recent call last):
        ...
    AttributeError: 'IsEnrolledOn' object has no attribute 'foo'
    >>> IsEnrolledOn(('course_id', 'name', 'student_id'),
    ...               ('C1', 'Anne', 'S1'),
    ...               ('C2', 'Anne', 'C1'),
    ...               )
    Traceback (most recent call last):
        ...
    TypeError: Expected 'S' followed by one to three digits; 'C1' is invalid in row 2



Relational Operators
--------------------

Analogous to how the classes used for defining row and relation types are
collected into the dinsd ``dbdef`` namespace, the methods used to define
various relational operators are defined in their own namespace, in this case
named ``op``.  It is annoying to type ``op.`` in front of the operators,
though, since we type them much more often than the dbdef class names.
So we'll import each operator at the start of the section discussing it.


Example Relations
~~~~~~~~~~~~~~~~~

Here are the two relations used in the examples in Chapter 4 of AIRDT:

    >>> class IsCalled(dbdef.Relation):
    ...     student_id = SID
    ...     name = str
    >>> is_called = IsCalled(
    ...     ('student_id',  'name'),
    ...     ('S1',          'Anne'),
    ...     ('S2',          'Boris'),
    ...     ('S3',          'Cindy'),
    ...     ('S4',          'Devinder'),
    ...     ('S5',          'Boris'),
    ...     )
    >>> print(is_called)
    +----------+------------+
    | name     | student_id |
    +----------+------------+
    | Anne     | S1         |
    | Boris    | S2         |
    | Boris    | S5         |
    | Cindy    | S3         |
    | Devinder | S4         |
    +----------+------------+
    >>> class IsEnrolledOn(dbdef.Relation):
    ...     student_id = SID
    ...     course_id = CID
    >>> is_enrolled_on = IsEnrolledOn(
    ...     ('student_id',  'course_id'),
    ...     ('S1',          'C1'),
    ...     ('S1',          'C2'),
    ...     ('S2',          'C1'),
    ...     ('S3',          'C3'),
    ...     ('S4',          'C1'),
    ...     )
    >>> print(is_enrolled_on)
    +-----------+------------+
    | course_id | student_id |
    +-----------+------------+
    | C1        | S1         |
    | C1        | S2         |
    | C1        | S4         |
    | C2        | S1         |
    | C3        | S3         |
    +-----------+------------+

Here we have changed the meaning of the names IsEnrolledOn and is_enrolled_on.
We would not be allowed to do this in *Tutorial D* or *TTM* without first
declaring variables as discarded and *then* defining new types for them.
Python sees that as pointless busywork and does not require it, but it is one
of the things that makes dinsd not TTM compliant.  (We will see later,
however, that disd *does* implement semi-statically-typed relvars inside
databases.)

Python keeps track of objects by pointer, though, not by name, so to Python
the type of the relation pointed to now by is_enrolled_on is different from
the type of the relation pointed to by the old is_enrolled_on variables, even
though the two relation types have the same identifier:

    >>> type(is_enrolled_on).__name__ == type(is_enrolled_on2).__name__
    True
    >>> type(is_enrolled_on) == type(is_enrolled_on2)
    False

That is, Python is *strongly typed*, even though it is also *dynamically
typed*.  (In fact, if you consider that it is really the object that is typed,
and that there are no real 'variables' in Python, just names that contain
references to objects, disnd probably does technically comply with TTM...but
not with its spirit, which requires static typing.)


display
~~~~~~~

``display`` is not a relational algebra function, but we introduce it here
because it is useful in the examples, and it is located in the ``op``
namespace.

    >>> from dinsd.op import display

The value returned by ``display`` is very similar to the value returned
by turning a relation in to a string, except that we can control the
order of the columns in the resulting table display.  Using ``display``
we can print the relations in the same column order that is used in AITDM:

    >>> print(display(is_called, 'student_id', 'name'))
    +------------+----------+
    | student_id | name     |
    +------------+----------+
    | S1         | Anne     |
    | S2         | Boris    |
    | S3         | Cindy    |
    | S4         | Devinder |
    | S5         | Boris    |
    +------------+----------+
    >>> print(display(is_enrolled_on, 'student_id', 'course_id'))
    +------------+-----------+
    | student_id | course_id |
    +------------+-----------+
    | S1         | C1        |
    | S1         | C2        |
    | S2         | C1        |
    | S3         | C3        |
    | S4         | C1        |
    +------------+-----------+


join
~~~~

    >>> from dinsd.op import join

Here is the straightforward ``join`` of the two tables above:

    >>> j = join(is_enrolled_on, is_called)
    >>> print(display(j, 'student_id', 'name', 'course_id'))
    +------------+----------+-----------+
    | student_id | name     | course_id |
    +------------+----------+-----------+
    | S1         | Anne     | C1        |
    | S1         | Anne     | C2        |
    | S2         | Boris    | C1        |
    | S3         | Cindy    | C3        |
    | S4         | Devinder | C1        |
    +------------+----------+-----------+

In *Tutorial D* the ``JOIN`` relational operator can be used both as a prefix
function and as a infix operator.  In Python we can't define new infix
operators, but we can override existing ones.  Since ``JOIN`` is, at base, the
logical ``and`` operator, it would make sense to override ``and`` for the
infix version of join.  However, we can't do that in Python, because ``and``
is a short circuit operator, whereas both arguments to a function must be
evaluated before the function can be called, and we can only override an
operator by defining a function.

What we can do, however, is override the arithmetic ``&`` operator:

    >>> j2 = is_enrolled_on & is_called
    >>> print(display(j2, 'student_id', 'name', 'course_id'))
    +------------+----------+-----------+
    | student_id | name     | course_id |
    +------------+----------+-----------+
    | S1         | Anne     | C1        |
    | S1         | Anne     | C2        |
    | S2         | Boris    | C1        |
    | S3         | Cindy    | C3        |
    | S4         | Devinder | C1        |
    +------------+----------+-----------+
    >>> j == j2
    True

The above join discussion takes us up to figure 4.2 on page 89 of AITDM, for
those following along in the book :).

On page 93 there is a discussion of cases where we *can't* perform a join.  In
particular, if two tables have columns with the same name but different types,
we cannot join them:

    >>> class PermissiveIds(dbdef.Relation):
    ...     student_id = str
    ...     name = str
    >>> permissive_is_called = PermissiveIds(
    ...     ('student_id', 'name'),
    ...     ('S1', 'Anne'),
    ...     ('S2', 'Boris'),
    ...     )
    >>> permissive_is_called & is_enrolled_on   # doctest: +NORMALIZE_WHITESPACE
    Traceback (most recent call last):
        ...
    TypeError: Duplicate attribute name ('student_id') with different type
        (first: <class 'str'>, second: <class '__main__.SID'> found in joined
        relvars of type <class '__main__.PermissiveIds'> and <class
        '__main__.IsEnrolledOn'>

An error like this in a multijoin also indicates in which argument the error
was detected:

    >>> join(is_enrolled_on, is_called,
    ...         permissive_is_called)         # doctest: +NORMALIZE_WHITESPACE
    Traceback (most recent call last):
        ...
    TypeError: Duplicate attribute name ('student_id') with different type
        (first: <class '__main__.SID'>, second: <class 'str'> found in joined
        relvars of type <class 'dinsd.dbdef.join_course_id_name_student_id'>
        and <class '__main__.PermissiveIds'> (error detected while processing
        argument 2)

In this error message you also get a peak at the names that are used for the
automatically generated ``Relation`` types used for the ``join`` result: a
concatenation of ``join`` and the attribute names, separated by '_'s.

If we join with an empty relation, we get an empty relation:

    >>> no_student_names = IsCalled()
    >>> print(no_student_names & is_enrolled_on)
    +-----------+------+------------+
    | course_id | name | student_id |
    +-----------+------+------------+
    +-----------+------+------------+

Join is idempotent: if we join a relation to itself, or if we join a relation
to the result of a previous join involving that relation, we get back the
original join:

    >>> j = is_enrolled_on & is_called
    >>> j == j & j
    True
    >>> j == j & is_called
    True

Join is commutative:

    >>> is_enrolled_on & is_called == is_called & is_enrolled_on
    True

Join is associative:

    >>> last_year = IsEnrolledOn(
    ...         ('student_id', 'course_id'),
    ...         ('S1',         'C3'),
    ...         ('S5',         'C3'),
    ...         ('S3',         'C3'),
    ...         )
    >>> (is_enrolled_on & is_called) & last_year == (
    ...     is_enrolled_on & (is_called & last_year))
    True


intersect
~~~~~~~~~

    >>> from dinsd.op import intersect

This is really a special case of ``join``: the case where all of the
attributes of the two relations being joined are the same.  It is
equivalent to the set-intersection of the two relations:

    >>> repeat_enrollment = intersect(is_enrolled_on, last_year)
    >>> print(display(repeat_enrollment, 'student_id', 'course_id'))
    +------------+-----------+
    | student_id | course_id |
    +------------+-----------+
    | S3         | C3        |
    +------------+-----------+
    >>> repeat_enrollment == is_enrolled_on & last_year
    True

There are two reasons to use ``intersect`` instead of ``join``.  The
first is that because the domain of operation is constrained, the
implementation may be faster.  The better reason to use it is that it
declares your intention to join two sets with the same attributes,
and will raise an error if the two sets do not have the same
attributes:

    >>> intersect(is_called, is_enrolled_on)
    Traceback (most recent call last):
        ...
    TypeError: Cannot take intersection of unlike relations


times
~~~~~

    >>> from dinsd.op import times

Another special case of ``join``.  I'm not as fond of this operator name, but
I can't think of a better one.  In this case, there are *no* attributes in
common between the two relations, and the result of the join is the Cartesian
product of the two sets of values.

Use cases for this are not common, so we won't even try to come up with a
sensible example:

    >>> class Foo(dbdef.Relation):
    ...     bar = str
    >>> foo = Foo(('bar',), ('fizz',), ('gin',))
    >>> print(times(last_year, foo))
    +------+-----------+------------+
    | bar  | course_id | student_id |
    +------+-----------+------------+
    | fizz | C3        | S1         |
    | fizz | C3        | S3         |
    | fizz | C3        | S5         |
    | gin  | C3        | S1         |
    | gin  | C3        | S3         |
    | gin  | C3        | S5         |
    +------+-----------+------------+

Here there is not likely to be any performance gain by using ``times``, but
the pedagogical value of getting an error if you try to ``times`` relations
that share columns is probably even more valuable.

    >>> times(is_called, last_year)
    Traceback (most recent call last):
        ...
    TypeError: Cannot multiply relations that share attributes

Like ``join``, ``intersect`` and ``times`` may be called with more than
two relations:

    >>> two_years_ago = IsEnrolledOn()
    >>> print(intersect(is_enrolled_on, last_year, two_years_ago))
    +-----------+------------+
    | course_id | student_id |
    +-----------+------------+
    +-----------+------------+
    >>> class Bar(dbdef.Relation):
    ...     foo = str
    >>> bar = Bar(('foo',), ('gin',), ('fiz',))
    >>> print(times(last_year, bar, foo))
    +------+-----------+-----+------------+
    | bar  | course_id | foo | student_id |
    +------+-----------+-----+------------+
    | fizz | C3        | fiz | S1         |
    | fizz | C3        | fiz | S3         |
    | fizz | C3        | fiz | S5         |
    | fizz | C3        | gin | S1         |
    | fizz | C3        | gin | S3         |
    | fizz | C3        | gin | S5         |
    | gin  | C3        | fiz | S1         |
    | gin  | C3        | fiz | S3         |
    | gin  | C3        | fiz | S5         |
    | gin  | C3        | gin | S1         |
    | gin  | C3        | gin | S3         |
    | gin  | C3        | gin | S5         |
    +------+-----------+-----+------------+
